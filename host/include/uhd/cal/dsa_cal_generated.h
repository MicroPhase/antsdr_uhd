// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DSACAL_UHD_USRP_CAL_H_
#define FLATBUFFERS_GENERATED_DSACAL_UHD_USRP_CAL_H_

#include "flatbuffers/flatbuffers.h"

#include "cal_metadata_generated.h"

namespace uhd {
namespace usrp {
namespace cal {

struct DsaStep;
struct DsaStepBuilder;

struct BandDsaMap;
struct BandDsaMapBuilder;

struct DsaCal;
struct DsaCalBuilder;

struct DsaStep FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DsaStepBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEPS = 4
  };
  const flatbuffers::Vector<uint32_t> *steps() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STEPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEPS) &&
           verifier.VerifyVector(steps()) &&
           verifier.EndTable();
  }
};

struct DsaStepBuilder {
  typedef DsaStep Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steps(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> steps) {
    fbb_.AddOffset(DsaStep::VT_STEPS, steps);
  }
  explicit DsaStepBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DsaStepBuilder &operator=(const DsaStepBuilder &);
  flatbuffers::Offset<DsaStep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DsaStep>(end);
    return o;
  }
};

inline flatbuffers::Offset<DsaStep> CreateDsaStep(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> steps = 0) {
  DsaStepBuilder builder_(_fbb);
  builder_.add_steps(steps);
  return builder_.Finish();
}

inline flatbuffers::Offset<DsaStep> CreateDsaStepDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *steps = nullptr) {
  auto steps__ = steps ? _fbb.CreateVector<uint32_t>(*steps) : 0;
  return uhd::usrp::cal::CreateDsaStep(
      _fbb,
      steps__);
}

struct BandDsaMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BandDsaMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX_FREQ = 4,
    VT_GAINS = 6,
    VT_NAME = 8
  };
  uint64_t max_freq() const {
    return GetField<uint64_t>(VT_MAX_FREQ, 0);
  }
  bool KeyCompareLessThan(const BandDsaMap *o) const {
    return max_freq() < o->max_freq();
  }
  int KeyCompareWithValue(uint64_t val) const {
    return static_cast<int>(max_freq() > val) - static_cast<int>(max_freq() < val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::DsaStep>> *gains() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::DsaStep>> *>(VT_GAINS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MAX_FREQ) &&
           VerifyOffset(verifier, VT_GAINS) &&
           verifier.VerifyVector(gains()) &&
           verifier.VerifyVectorOfTables(gains()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct BandDsaMapBuilder {
  typedef BandDsaMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max_freq(uint64_t max_freq) {
    fbb_.AddElement<uint64_t>(BandDsaMap::VT_MAX_FREQ, max_freq, 0);
  }
  void add_gains(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::DsaStep>>> gains) {
    fbb_.AddOffset(BandDsaMap::VT_GAINS, gains);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BandDsaMap::VT_NAME, name);
  }
  explicit BandDsaMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BandDsaMapBuilder &operator=(const BandDsaMapBuilder &);
  flatbuffers::Offset<BandDsaMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BandDsaMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<BandDsaMap> CreateBandDsaMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t max_freq = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::DsaStep>>> gains = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  BandDsaMapBuilder builder_(_fbb);
  builder_.add_max_freq(max_freq);
  builder_.add_name(name);
  builder_.add_gains(gains);
  return builder_.Finish();
}

inline flatbuffers::Offset<BandDsaMap> CreateBandDsaMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t max_freq = 0,
    const std::vector<flatbuffers::Offset<uhd::usrp::cal::DsaStep>> *gains = nullptr,
    const char *name = nullptr) {
  auto gains__ = gains ? _fbb.CreateVector<flatbuffers::Offset<uhd::usrp::cal::DsaStep>>(*gains) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return uhd::usrp::cal::CreateBandDsaMap(
      _fbb,
      max_freq,
      gains__,
      name__);
}

struct DsaCal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DsaCalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA = 4,
    VT_BAND_DSA_MAP = 6
  };
  const Metadata *metadata() const {
    return GetPointer<const Metadata *>(VT_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::BandDsaMap>> *band_dsa_map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::BandDsaMap>> *>(VT_BAND_DSA_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           VerifyOffset(verifier, VT_BAND_DSA_MAP) &&
           verifier.VerifyVector(band_dsa_map()) &&
           verifier.VerifyVectorOfTables(band_dsa_map()) &&
           verifier.EndTable();
  }
};

struct DsaCalBuilder {
  typedef DsaCal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata(flatbuffers::Offset<Metadata> metadata) {
    fbb_.AddOffset(DsaCal::VT_METADATA, metadata);
  }
  void add_band_dsa_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::BandDsaMap>>> band_dsa_map) {
    fbb_.AddOffset(DsaCal::VT_BAND_DSA_MAP, band_dsa_map);
  }
  explicit DsaCalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DsaCalBuilder &operator=(const DsaCalBuilder &);
  flatbuffers::Offset<DsaCal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DsaCal>(end);
    return o;
  }
};

inline flatbuffers::Offset<DsaCal> CreateDsaCal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Metadata> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<uhd::usrp::cal::BandDsaMap>>> band_dsa_map = 0) {
  DsaCalBuilder builder_(_fbb);
  builder_.add_band_dsa_map(band_dsa_map);
  builder_.add_metadata(metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<DsaCal> CreateDsaCalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Metadata> metadata = 0,
    std::vector<flatbuffers::Offset<uhd::usrp::cal::BandDsaMap>> *band_dsa_map = nullptr) {
  auto band_dsa_map__ = band_dsa_map ? _fbb.CreateVectorOfSortedTables<uhd::usrp::cal::BandDsaMap>(band_dsa_map) : 0;
  return uhd::usrp::cal::CreateDsaCal(
      _fbb,
      metadata,
      band_dsa_map__);
}

inline const uhd::usrp::cal::DsaCal *GetDsaCal(const void *buf) {
  return flatbuffers::GetRoot<uhd::usrp::cal::DsaCal>(buf);
}

inline const uhd::usrp::cal::DsaCal *GetSizePrefixedDsaCal(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<uhd::usrp::cal::DsaCal>(buf);
}

inline const char *DsaCalIdentifier() {
  return "dsas";
}

inline bool DsaCalBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, DsaCalIdentifier());
}

inline bool VerifyDsaCalBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<uhd::usrp::cal::DsaCal>(DsaCalIdentifier());
}

inline bool VerifySizePrefixedDsaCalBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<uhd::usrp::cal::DsaCal>(DsaCalIdentifier());
}

inline const char *DsaCalExtension() {
  return "cal";
}

inline void FinishDsaCalBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<uhd::usrp::cal::DsaCal> root) {
  fbb.Finish(root, DsaCalIdentifier());
}

inline void FinishSizePrefixedDsaCalBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<uhd::usrp::cal::DsaCal> root) {
  fbb.FinishSizePrefixed(root, DsaCalIdentifier());
}

}  // namespace cal
}  // namespace usrp
}  // namespace uhd

#endif  // FLATBUFFERS_GENERATED_DSACAL_UHD_USRP_CAL_H_
