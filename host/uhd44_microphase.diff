diff --git a/host/lib/CMakeLists.txt b/host/lib/CMakeLists.txt
index 351e0a170..b09147fae 100644
--- a/host/lib/CMakeLists.txt
+++ b/host/lib/CMakeLists.txt
@@ -65,6 +65,7 @@ LIBUHD_REGISTER_COMPONENT("USB" ENABLE_USB ON "ENABLE_LIBUHD;LIBUSB_FOUND" OFF O
 # Devices
 LIBUHD_REGISTER_COMPONENT("B100" ENABLE_B100 ON "ENABLE_LIBUHD;ENABLE_USB" OFF OFF)
 LIBUHD_REGISTER_COMPONENT("B200" ENABLE_B200 ON "ENABLE_LIBUHD;ENABLE_USB" OFF OFF)
+LIBUHD_REGISTER_COMPONENT("ANT" ENABLE_ANT ON "ENABLE_LIBUHD;ENABLE_USB" OFF OFF)
 LIBUHD_REGISTER_COMPONENT("USRP1" ENABLE_USRP1 ON "ENABLE_LIBUHD;ENABLE_USB" OFF OFF)
 LIBUHD_REGISTER_COMPONENT("USRP2" ENABLE_USRP2 ON "ENABLE_LIBUHD" OFF OFF)
 LIBUHD_REGISTER_COMPONENT("X300" ENABLE_X300 ON "ENABLE_LIBUHD" OFF OFF)
diff --git a/host/lib/usrp/CMakeLists.txt b/host/lib/usrp/CMakeLists.txt
index 570972f16..4183d9f9c 100644
--- a/host/lib/usrp/CMakeLists.txt
+++ b/host/lib/usrp/CMakeLists.txt
@@ -42,3 +42,4 @@ INCLUDE_SUBDIRECTORY(b100)
 INCLUDE_SUBDIRECTORY(x300)
 INCLUDE_SUBDIRECTORY(b200)
 INCLUDE_SUBDIRECTORY(x400)
+INCLUDE_SUBDIRECTORY(ant)
\ No newline at end of file
diff --git a/host/lib/usrp/ant/CMakeLists.txt b/host/lib/usrp/ant/CMakeLists.txt
new file mode 100644
index 000000000..32616f088
--- /dev/null
+++ b/host/lib/usrp/ant/CMakeLists.txt
@@ -0,0 +1,23 @@
+#
+# Copyright 2012-2013,2015 Ettus Research LLC
+# Copyright 2018 Ettus Research, a National Instruments Company
+#
+# SPDX-License-Identifier: GPL-3.0-or-later
+#
+
+########################################################################
+# This file included, use CMake directory variables
+########################################################################
+
+########################################################################
+# Conditionally configure the ANT support
+########################################################################
+if(ENABLE_ANT)
+    LIBUHD_APPEND_SOURCES(
+        ${CMAKE_CURRENT_SOURCE_DIR}/ant_impl.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/ant_io_impl.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/ant_uart.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/ant_cores.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/ant_radio_ctrl_core.cpp
+    )
+endif(ENABLE_ANT)
diff --git a/host/lib/usrp/ant/ant_cores.cpp b/host/lib/usrp/ant/ant_cores.cpp
new file mode 100644
index 000000000..62775c461
--- /dev/null
+++ b/host/lib/usrp/ant/ant_cores.cpp
@@ -0,0 +1,69 @@
+//
+// Copyright 2013-2014 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#include "ant_cores.hpp"
+#include "ant_impl.hpp"
+#include "ant_regs.hpp"
+#include <mutex>
+
+ant_local_spi_core::ant_local_spi_core(uhd::wb_iface::sptr iface, perif_t default_perif)
+    : _spi_core(spi_core_3000::make(iface, TOREG(SR_CORE_SPI), RB32_CORE_SPI))
+    , _current_perif(default_perif)
+    , _last_perif(default_perif)
+{
+    change_perif(default_perif);
+}
+
+uint32_t ant_local_spi_core::transact_spi(int which_slave,
+    const uhd::spi_config_t& config,
+    uint32_t data,
+    size_t num_bits,
+    bool readback)
+{
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _spi_core->transact_spi(which_slave, config, data, num_bits, readback);
+}
+
+void ant_local_spi_core::change_perif(perif_t perif)
+{
+    std::lock_guard<std::mutex> lock(_mutex);
+    _last_perif    = _current_perif;
+    _current_perif = perif;
+
+    switch (_current_perif) {
+        case CODEC:
+            _spi_core->set_divider(ANT_BUS_CLOCK_RATE / AD9361_SPI_RATE);
+            break;
+        case PLL:
+            _spi_core->set_divider(ANT_BUS_CLOCK_RATE / ADF4001_SPI_RATE);
+            break;
+    }
+}
+
+void ant_local_spi_core::restore_perif()
+{
+    change_perif(_last_perif);
+}
+
+ant_ref_pll_ctrl::ant_ref_pll_ctrl(ant_local_spi_core::sptr spi)
+    : uhd::usrp::adf4001_ctrl(spi, ADF4001_SLAVENO), _spi(spi)
+{
+}
+
+void ant_ref_pll_ctrl::set_lock_to_ext_ref(bool external)
+{
+    _spi->change_perif(ant_local_spi_core::PLL);
+    adf4001_ctrl::set_lock_to_ext_ref(external);
+    _spi->restore_perif();
+}
+
+
+ant_local_spi_core::sptr ant_local_spi_core::make(
+    uhd::wb_iface::sptr iface, ant_local_spi_core::perif_t default_perif)
+{
+    return sptr(new ant_local_spi_core(iface, default_perif));
+}
diff --git a/host/lib/usrp/ant/ant_cores.hpp b/host/lib/usrp/ant/ant_cores.hpp
new file mode 100644
index 000000000..41651d4e1
--- /dev/null
+++ b/host/lib/usrp/ant/ant_cores.hpp
@@ -0,0 +1,57 @@
+//
+// Copyright 2013-2014 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+// Copyright 2019 Ettus Research, a National Instruments Brand
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#ifndef INCLUDED_ANT_CORES_HPP
+#define INCLUDED_ANT_CORES_HPP
+
+#include <uhd/utils/noncopyable.hpp>
+#include <uhdlib/usrp/common/adf4001_ctrl.hpp>
+#include <uhdlib/usrp/cores/spi_core_3000.hpp>
+#include <memory>
+#include <mutex>
+
+class ant_local_spi_core : uhd::noncopyable, public uhd::spi_iface
+{
+public:
+    typedef std::shared_ptr<ant_local_spi_core> sptr;
+
+    enum perif_t { CODEC, PLL };
+
+    ant_local_spi_core(uhd::wb_iface::sptr iface, perif_t default_perif);
+
+    uint32_t transact_spi(int which_slave,
+        const uhd::spi_config_t& config,
+        uint32_t data,
+        size_t num_bits,
+        bool readback) override;
+
+    void change_perif(perif_t perif);
+    void restore_perif();
+
+    static sptr make(uhd::wb_iface::sptr iface, perif_t default_perif = CODEC);
+
+private:
+    spi_core_3000::sptr _spi_core;
+    perif_t _current_perif;
+    perif_t _last_perif;
+    std::mutex _mutex;
+};
+
+class ant_ref_pll_ctrl : public uhd::usrp::adf4001_ctrl
+{
+public:
+    typedef std::shared_ptr<ant_ref_pll_ctrl> sptr;
+
+    ant_ref_pll_ctrl(ant_local_spi_core::sptr spi);
+    void set_lock_to_ext_ref(bool external) override;
+
+private:
+    ant_local_spi_core::sptr _spi;
+};
+
+#endif /* INCLUDED_ANT_CORES_HPP */
diff --git a/host/lib/usrp/ant/ant_impl.cpp b/host/lib/usrp/ant/ant_impl.cpp
new file mode 100644
index 000000000..5e0ac6bdb
--- /dev/null
+++ b/host/lib/usrp/ant/ant_impl.cpp
@@ -0,0 +1,1316 @@
+//
+// Copyright 2012-2015 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#include "ant_impl.hpp"
+#include "../../transport/libusb1_base.hpp"
+#include "ant_regs.hpp"
+#include <uhd/cal/database.hpp>
+#include <uhd/config.hpp>
+#include <uhd/exception.hpp>
+#include <uhd/transport/usb_control.hpp>
+#include <uhd/usrp/dboard_eeprom.hpp>
+#include <uhd/utils/cast.hpp>
+#include <uhd/utils/log.hpp>
+#include <uhd/utils/paths.hpp>
+#include <uhd/utils/safe_call.hpp>
+#include <uhd/utils/static.hpp>
+#include <boost/filesystem.hpp>
+#include <boost/format.hpp>
+#include <boost/functional/hash.hpp>
+#include <boost/lexical_cast.hpp>
+#include <chrono>
+#include <cmath>
+#include <cstdio>
+#include <ctime>
+#include <functional>
+#include <memory>
+
+
+#include "uhd/transport/if_addrs.hpp"
+#include "uhd/utils/byteswap.hpp"
+#include <arpa/inet.h>
+/* if windows #include<Winsock2.h> */
+#include "uhd/transport/udp_zero_copy.hpp"
+#include <boost/asio/ip/address_v4.hpp>
+
+using namespace uhd;
+using namespace uhd::usrp;
+using namespace uhd::usrp::gpio_atr;
+using namespace uhd::transport;
+
+namespace {
+constexpr int64_t REENUMERATION_TIMEOUT_MS = 3000;
+}
+
+// B205
+class b2xxmini_ad9361_client_t : public ad9361_params
+{
+public:
+    ~b2xxmini_ad9361_client_t() override {}
+    double get_band_edge(frequency_band_t band) override
+    {
+        switch (band) {
+            case AD9361_RX_BAND0:
+                return 0; // Set these all to
+            case AD9361_RX_BAND1:
+                return 0; // zero, so RF port A
+            case AD9361_TX_BAND0:
+                return 0; // is used all the time
+            default:
+                return 0; // On both Rx and Tx
+        }
+    }
+    clocking_mode_t get_clocking_mode() override
+    {
+        return clocking_mode_t::AD9361_XTAL_N_CLK_PATH;
+    }
+    digital_interface_mode_t get_digital_interface_mode() override
+    {
+        return AD9361_DDR_FDD_LVCMOS;
+    }
+    digital_interface_delays_t get_digital_interface_timing() override
+    {
+        digital_interface_delays_t delays;
+        delays.rx_clk_delay  = 0;
+        delays.rx_data_delay = 0xF;
+        delays.tx_clk_delay  = 0;
+        delays.tx_data_delay = 0xF;
+        return delays;
+    }
+};
+
+/***********************************************************************
+ * Helpers
+ **********************************************************************/
+std::string ant_check_option_valid(const std::string& name,
+    const std::vector<std::string>& valid_options,
+    const std::string& option)
+{
+    if (std::find(valid_options.begin(), valid_options.end(), option)
+        == valid_options.end()) {
+        throw uhd::runtime_error(
+            str(boost::format("Invalid option chosen for: %s") % name));
+    }
+
+    return option;
+}
+
+/***********************************************************************
+ * Discovery
+ **********************************************************************/
+
+static device_addrs_t ant_find(const device_addr_t& hint)
+{
+    device_addrs_t hints = separate_device_addr(hint);
+    if(hints.size() > 1){
+        device_addrs_t found_devices;
+        std::string error_msg;
+        for(const device_addr_t& hint_i : hints){
+            device_addrs_t found_device_i = ant_find(hint_i);
+            if(found_device_i.size() != 1)
+                error_msg +=
+                        str(boost::format(
+                                "Could not resolve device hint \"%s\" to a single device.")
+                            % hint_i.to_string());
+            else
+                found_devices.push_back(found_device_i[0]);
+        }
+        if(found_devices.empty())
+            return device_addrs_t();
+        if(not error_msg.empty())
+            throw uhd::value_error(error_msg);
+        return device_addrs_t(1, combine_device_addrs(found_devices));
+    }
+
+    // initialize the hint for a single device case
+    UHD_ASSERT_THROW(hints.size() <= 1);
+    hints.resize(1);
+    device_addr_t hint_ = hints[0];
+    device_addrs_t ant_addrs;
+
+    // return an empty list of addresses when type is set to non-b200
+    if (hint_.has_key("type") and hint["type"] != "ant")
+        return ant_addrs;
+
+    if(not hint_.has_key("addr")){
+        for(const if_addrs_t& if_addrs : get_if_addrs()){
+            if(if_addrs.inet == boost::asio::ip::address_v4::loopback().to_string())
+                continue;
+
+            device_addr_t new_hint = hint;
+            new_hint["addr"] = if_addrs.bcast;
+
+            device_addrs_t new_ant_addrs = ant_find(new_hint);
+            ant_addrs.insert(
+                    ant_addrs.begin(),new_ant_addrs.begin(),new_ant_addrs.end());
+        }
+        return ant_addrs;
+    }
+    /* connect the device from ethernet "addr=" */
+    udp_simple::sptr udp_transport;
+    try {
+        udp_transport = udp_simple::make_broadcast(
+                hint_["addr"], BOOST_STRINGIZE(MICROPHASE_ANT_UDP_FIND_PORT));
+    } catch (const std::exception &e) {
+        UHD_LOGGER_ERROR("Microphase")
+                << "Cannot open UDP transport on " << hint_["addr"] << ":" << e.what();
+        return ant_addrs;
+    }
+
+    //send a hello control packet
+    microphase_ant_ctrl_data_t ctrl_data_out = microphase_ant_ctrl_data_t();
+    ctrl_data_out.check = uhd::htonx<uint32_t>(MICROPHASE_CHECK);
+    ctrl_data_out.id = uhd::htonx<uint32_t >(MICROPHASE_CTRL_ID_WAZZUP_BR0);
+    ctrl_data_out.serial = uhd::htonx<uint32_t >(MICROPHASE_SERIAL_BR0);
+    ctrl_data_out.auth = uhd::htonx<uint32_t >(MICROPHASE_AUTHOR_BR0);
+    try {
+        udp_transport->send(boost::asio::buffer(&ctrl_data_out, sizeof(ctrl_data_out)));
+    } catch (const std::exception &ex) {
+        UHD_LOGGER_ERROR("Microphase ANT") << "ANT Network discovery error" << ex.what();
+    } catch (...) {
+        UHD_LOGGER_ERROR("Microphase ANT") << "ANT Network discovery unkonwn error";
+    }
+    //loop and recieve until the timeout
+    uint8_t microphase_ant_ctrl_data_in_mem[udp_simple::mtu];
+
+    const microphase_ant_ctrl_data_t *ctrl_data_in =
+            reinterpret_cast<const microphase_ant_ctrl_data_t *>(microphase_ant_ctrl_data_in_mem);
+
+    while (true) {
+        size_t len = udp_transport->recv(boost::asio::buffer(microphase_ant_ctrl_data_in_mem));
+        if (len > offsetof(microphase_ant_ctrl_data_t, serial)
+            and ntohl(ctrl_data_in->id) == MICROPHASE_CTRL_ID_WAZZUP_DUDE
+            and ntohl(ctrl_data_in->check) == MICROPHASE_CHECK
+            and ntohl(ctrl_data_in->serial) == MICROPHASE_SERIAL_DUDE
+            and ntohl(ctrl_data_in->auth) == MICROPHASE_AUTHOR_DUDE) {
+            // make a boost asio ipv4 with the raw addr in host byte order1
+
+            device_addr_t mp_addr;
+            mp_addr["type"] = "ant";
+            mp_addr["addr"] = udp_transport->get_recv_addr();
+
+            udp_simple::sptr ctrl_xport = udp_simple::make_connected(
+                    mp_addr["addr"], BOOST_STRINGIZE(MICROPHASE_ANT_UDP_FIND_PORT)
+            );
+            udp_transport->send(boost::asio::buffer(&ctrl_data_out, sizeof(ctrl_data_out)));
+            size_t len = udp_transport->recv(boost::asio::buffer(microphase_ant_ctrl_data_in_mem));
+            if (len > offsetof(microphase_ant_ctrl_data_t, serial)
+                and ntohl(ctrl_data_in->id) == MICROPHASE_CTRL_ID_WAZZUP_DUDE
+                and ntohl(ctrl_data_in->check) == MICROPHASE_CHECK
+                and ntohl(ctrl_data_in->serial) == MICROPHASE_SERIAL_DUDE
+                and ntohl(ctrl_data_in->auth) == MICROPHASE_AUTHOR_DUDE) {
+                uint8_t serial[32];
+                memcpy(serial,ctrl_data_in->serial_all,sizeof(serial));
+                std::string serial_str((char *)serial);
+                std::transform(serial_str.begin(),serial_str.end(),serial_str.begin(),::toupper);
+                uint8_t board_version[8];
+                memcpy(board_version,ctrl_data_in->board_version,sizeof(board_version));
+                std::string board_str((char*)board_version,sizeof(board_version));
+                if(board_str.size() < 8)
+                    mp_addr["product"] = "E200";
+                else
+                    mp_addr["product"] = board_str;
+                mp_addr["serial"] = serial_str;
+                mp_addr["name"] = "ANTSDR-E200";
+                // found the device,open up for communication!
+                ant_addrs.push_back(mp_addr);
+            } else {
+                continue;
+            }
+        }
+        if (len == 0)
+            break;
+    }
+    return ant_addrs;
+}
+
+/***********************************************************************
+ * Make
+ **********************************************************************/
+static device::sptr ant_make(const device_addr_t& device_addr)
+{
+    // We try twice, because the first time, the link might be in a bad state
+    // and we might need to reset the link, but if that didn't help, trying
+    // a third time is pointless.
+    try {
+        return device::sptr(new ant_impl(device_addr));
+    } catch (const uhd::usb_error&) {
+        UHD_LOGGER_INFO("ANT") << "Detected bad USB state; resetting.";
+    }
+
+    return device::sptr(new ant_impl(device_addr));
+}
+
+UHD_STATIC_BLOCK(register_ant_device)
+{
+    device::register_device(&ant_find, &ant_make, device::USRP);
+}
+
+/***********************************************************************
+ * Structors
+ **********************************************************************/
+ant_impl::ant_impl(
+    const uhd::device_addr_t& device_addr)
+    : _product(B200)
+    , // Some safe value
+    _revision(0)
+    , _enable_user_regs(device_addr.has_key("enable_user_regs"))
+    , _time_source(UNKNOWN)
+    , _time_set_with_pps(false)
+    , _tick_rate(0.0) // Forces a clock initialization at startup
+{
+    _tree                 = property_tree::make();
+    _type                 = device::USRP;
+    const fs_path mb_path = "/mboards/0";
+
+    if (device_addr.has_key("type") && device_addr["type"] == "ant") {
+        /* Microphase not use usb
+         * and not eeprom
+         * so there is no iface
+         * */
+
+        /* set the product is B200
+         * because the e310 is using b200_driver
+         * */
+        _product = B210;
+        _product_mp = E310;
+        const std::string addr = device_addr["addr"];
+        UHD_LOGGER_INFO("ANT") << "Detected Device: ANTSDR";
+
+        mboard_eeprom_t mb_eeprom;
+        mb_eeprom["magic"] = "45568";
+        mb_eeprom["eeprom_revision"] = "v0.1";
+        mb_eeprom["eeprom_compat"] = "1";
+        mb_eeprom["product"] = "MICROPHASE";
+        mb_eeprom["name"] = "ANT";
+        mb_eeprom["serial"] = device_addr["serial"];
+        _tree->create<mboard_eeprom_t>(mb_path / "eeprom")
+                .set(mb_eeprom)
+                .add_coerced_subscriber(
+                        std::bind(&ant_impl::set_mb_eeprom, this)
+                );
+
+        _gpsdo_capable = 0;
+
+        ////////////////////////////////////////////////////////////////////
+        // Set up frontend mapping
+        ////////////////////////////////////////////////////////////////////
+        // Explanation: The AD9361 has 2 frontends, FE1 and FE2.
+        // On the B210 FE1 maps to the B-side (or radio 1), and FE2 maps
+        // to the A-side (or radio 0). So, logically, the radios are swapped
+        // between the host side and the AD9361-side.
+        // ANT is more complicated: On Revs <= 4, the A-side is connected,
+        // which means FE2 is used (like B210). On Revs >= 5, the left side
+        // ("B-side") is connected, because these revs use an AD9364, which
+        // does not have an FE2, so we don't swap FEs.
+
+        // Swapped setup:
+        //_fe1                 = 1;
+        //_fe2                 = 0;
+        //_gpio_state.swap_atr = 1;
+        // Unswapped setup:
+        _fe1 = 0;
+        _fe2 = 1;
+        _gpio_state.swap_atr = 0;
+        if (_product == B200MINI or _product == B205MINI
+            or (_product == B200 and _revision >= 5)) {
+            _fe1 = 0; // map radio0 to FE1
+            _fe2 = 1; // map radio1 to FE2
+            _gpio_state.swap_atr = 0; // ATRs for radio0 are mapped to FE1
+        }
+
+        zero_copy_xport_params default_buff_args;
+        default_buff_args.send_frame_size = transport::udp_simple::mtu;
+        default_buff_args.recv_frame_size = transport::udp_simple::mtu;
+        default_buff_args.num_send_frames = 16;
+        default_buff_args.num_recv_frames = 16;
+        default_buff_args.send_buff_size = 1e6;
+        default_buff_args.recv_buff_size = 1e6;
+
+
+        /* make the transprt object with the hintS
+              * create the transport port (_ctrl_transport)
+              * */
+        device_addr_t filtered_hints;
+        udp_zero_copy::buff_params ignored_params;
+
+        _ctrl_transport = udp_zero_copy::make(
+                addr, BOOST_STRINGIZE(MICROPHASE_ANT_UDP_CTRL_PORT), default_buff_args, ignored_params,
+                filtered_hints);
+        while (_ctrl_transport->get_recv_buff(0.0)) {
+        } // flush ctrl xport
+
+        ////////////////////////////////////////////////////////////////////
+        // Async task structure
+        ////////////////////////////////////////////////////////////////////
+        _async_task_data.reset(new AsyncTaskData());
+        _async_task_data->async_md.reset(new async_md_type(1000 /*messages deep*/));
+        if (_gpsdo_capable) {
+            _async_task_data->gpsdo_uart =
+                    ant_uart::make(_ctrl_transport, ANT_TX_GPS_UART_SID);
+        }
+        _async_task = uhd::msg_task::make(std::bind(
+                &ant_impl::handle_async_task, this, _ctrl_transport, _async_task_data));
+
+        ////////////////////////////////////////////////////////////////////
+        // Local control endpoint
+        ////////////////////////////////////////////////////////////////////
+        _local_ctrl = ant_radio_ctrl_core::make(false /*lilE*/,
+                                                _ctrl_transport,
+                                                zero_copy_if::sptr() /*null*/,
+                                                ANT_LOCAL_CTRL_SID);
+        _local_ctrl->hold_task(_async_task);
+        _async_task_data->local_ctrl = _local_ctrl; // weak
+        this->check_fpga_compat();
+
+        /* Initialize the GPIOs, set the default bandsels to the lower range. Note
+         * that calling update_bandsel calls update_gpio_state(). */
+        update_bandsel("RX", 800e6);
+        update_bandsel("TX", 850e6);
+
+        ////////////////////////////////////////////////////////////////////
+        // Create the GPSDO control
+        ////////////////////////////////////////////////////////////////////
+        if (_gpsdo_capable) {
+            if ((_local_ctrl->peek32(RB32_CORE_STATUS) & 0xff) != ANT_GPSDO_ST_NONE) {
+                UHD_LOGGER_INFO("ANT") << "Detecting internal GPSDO.... " << std::flush;
+                try {
+                    _gps = gps_ctrl::make(_async_task_data->gpsdo_uart);
+                } catch (std::exception &e) {
+                    UHD_LOGGER_ERROR("ANT")
+                            << "An error occurred making GPSDO control: " << e.what();
+                }
+                if (_gps and _gps->gps_detected()) {
+                    for (const std::string &name: _gps->get_sensors()) {
+                        _tree->create<sensor_value_t>(mb_path / "sensors" / name)
+                                .set_publisher(std::bind(&gps_ctrl::get_sensor, _gps, name));
+                    }
+                } else {
+                    _local_ctrl->poke32(TOREG(SR_CORE_GPSDO_ST), ANT_GPSDO_ST_NONE);
+                }
+            }
+        }
+
+        ////////////////////////////////////////////////////////////////////
+        // Initialize the properties tree
+        ////////////////////////////////////////////////////////////////////
+        std::string product_name = "B210";
+        _tree->create<std::string>("/name").set("B-Series Device");
+        _tree->create<std::string>(mb_path / "name").set(product_name);
+        _tree->create<std::string>(mb_path / "codename")
+                .set((_product == B200MINI or _product == B205MINI) ? "Pixie" : "Sasquatch");
+
+        ////////////////////////////////////////////////////////////////////
+        // Create data transport
+        ////////////////////////////////////////////////////////////////////
+        udp_zero_copy::buff_params ignored_out_params;
+        device_addr_t fi_hints;
+        _data_rx_transport = udp_zero_copy::make(
+                addr, BOOST_STRINGIZE(MICROPHASE_ANT_UDP_DATA_RX_PORT), default_buff_args,
+                ignored_out_params, fi_hints);
+        if (_data_rx_transport.get()) {
+            _program_dispatcher(*_data_rx_transport);
+        }
+        while (_data_rx_transport->get_recv_buff(0.0)) {
+        } // flush ctrl xport
+        _demux = recv_packet_demuxer_3000::make(_data_rx_transport);
+
+        _data_tx_transport = udp_zero_copy::make(
+                addr, BOOST_STRINGIZE(MICROPHASE_ANT_UDP_DATA_TX_PORT), default_buff_args,
+                ignored_out_params, fi_hints);
+        while (_data_tx_transport->get_recv_buff(0.0)) {
+        }
+        _data_tx1_transport = udp_zero_copy::make(
+                addr, BOOST_STRINGIZE(MICROPHASE_ANT_UDP_DATA_TX1_PORT), default_buff_args,
+                ignored_out_params, fi_hints);
+        while (_data_tx1_transport->get_recv_buff(0.0)) {
+        }
+
+        ////////////////////////////////////////////////////////////////////
+        // create time and clock control objects
+        ////////////////////////////////////////////////////////////////////
+        _spi_iface = ant_local_spi_core::make(_local_ctrl);
+        _adf4001_iface = std::make_shared<ant_ref_pll_ctrl>(_spi_iface);
+
+        ////////////////////////////////////////////////////////////////////
+        // Init codec - turns on clocks
+        ////////////////////////////////////////////////////////////////////
+        UHD_LOGGER_INFO("ANT") << "Initialize CODEC control...";
+        reset_codec();
+        ad9361_params::sptr client_settings;
+        client_settings = std::make_shared<b2xxmini_ad9361_client_t>();
+
+        _codec_ctrl = ad9361_ctrl::make_spi(client_settings, _spi_iface, AD9361_SLAVENO);
+
+        ////////////////////////////////////////////////////////////////////
+        // create codec control objects
+        ////////////////////////////////////////////////////////////////////
+        {
+            const fs_path codec_path = mb_path / ("rx_codecs") / "A";
+            _tree->create<std::string>(codec_path / "name")
+                    .set(product_name + " RX dual ADC");
+            _tree->create<int>(codec_path / "gains"); // empty cuz gains are in frontend
+        }
+        {
+            const fs_path codec_path = mb_path / ("tx_codecs") / "A";
+            _tree->create<std::string>(codec_path / "name")
+                    .set(product_name + " TX dual DAC");
+            _tree->create<int>(codec_path / "gains"); // empty cuz gains are in frontend
+        }
+
+        ////////////////////////////////////////////////////////////////////
+        // create clock control objects
+        ////////////////////////////////////////////////////////////////////
+        _tree->create<double>(mb_path / "tick_rate")
+                .set_coercer(std::bind(&ant_impl::set_tick_rate, this, std::placeholders::_1))
+                .set_publisher(std::bind(&ant_impl::get_tick_rate, this))
+                .add_coerced_subscriber(
+                        std::bind(&ant_impl::update_tick_rate, this, std::placeholders::_1));
+        _tree->create<meta_range_t>(mb_path / "tick_rate/range").set_publisher([this]() {
+            return this->_codec_ctrl->get_clock_rate_range();
+        });
+        _tree->create<time_spec_t>(mb_path / "time" / "cmd");
+        _tree->create<bool>(mb_path / "auto_tick_rate").set(false);
+
+        ////////////////////////////////////////////////////////////////////
+        // and do the misc mboard sensors
+        ////////////////////////////////////////////////////////////////////
+        _tree->create<sensor_value_t>(mb_path / "sensors" / "ref_locked")
+                .set_publisher(std::bind(&ant_impl::get_ref_locked, this));
+
+        ////////////////////////////////////////////////////////////////////
+        // create frontend mapping
+        ////////////////////////////////////////////////////////////////////
+        std::vector<size_t> default_map(2, 0);
+        default_map[1] = 1; // Set this to A->0 B->1 even if there's only A
+        _tree->create<std::vector<size_t>>(mb_path / "rx_chan_dsp_mapping").set(default_map);
+        _tree->create<std::vector<size_t>>(mb_path / "tx_chan_dsp_mapping").set(default_map);
+        _tree->create<subdev_spec_t>(mb_path / "rx_subdev_spec")
+                .set_coercer(
+                        std::bind(&ant_impl::coerce_subdev_spec, this, std::placeholders::_1))
+                .set(subdev_spec_t())
+                .add_coerced_subscriber(
+                        std::bind(&ant_impl::update_subdev_spec, this, "rx", std::placeholders::_1));
+        _tree->create<subdev_spec_t>(mb_path / "tx_subdev_spec")
+                .set_coercer(
+                        std::bind(&ant_impl::coerce_subdev_spec, this, std::placeholders::_1))
+                .set(subdev_spec_t())
+                .add_coerced_subscriber(
+                        std::bind(&ant_impl::update_subdev_spec, this, "tx", std::placeholders::_1));
+
+        ////////////////////////////////////////////////////////////////////
+        // setup radio control
+        ////////////////////////////////////////////////////////////////////
+        UHD_LOGGER_INFO("ANT") << "Initialize Radio control...";
+        const size_t num_radio_chains = ((_local_ctrl->peek32(RB32_CORE_STATUS) >> 8) & 0xff);
+        UHD_ASSERT_THROW(num_radio_chains > 0);
+        UHD_ASSERT_THROW(num_radio_chains <= 2);
+        _radio_perifs.resize(num_radio_chains);
+        _codec_mgr = ad936x_manager::make(_codec_ctrl, num_radio_chains);
+        _codec_mgr->init_codec();
+        for (size_t i = 0; i < _radio_perifs.size(); i++)
+            this->setup_radio(i);
+
+        // now test each radio module's connection to the codec interface
+        for (radio_perifs_t &perif: _radio_perifs) {
+            _codec_mgr->loopback_self_test(
+                    [&perif](const uint32_t value) {
+                        perif.ctrl->poke32(TOREG(SR_CODEC_IDLE), value);
+                    },
+                    [&perif]() { return perif.ctrl->peek64(RB64_CODEC_READBACK); });
+        }
+
+        // register time now and pps onto available radio cores
+        _tree->create<time_spec_t>(mb_path / "time" / "now")
+                .set_publisher(std::bind(&time_core_3000::get_time_now, _radio_perifs[0].time64))
+                .add_coerced_subscriber(
+                        std::bind(&ant_impl::set_time, this, std::placeholders::_1))
+                .set(0.0);
+        // re-sync the times when the tick rate changes
+        _tree->access<double>(mb_path / "tick_rate")
+                .add_coerced_subscriber(std::bind(&ant_impl::sync_times, this));
+        _tree->create<time_spec_t>(mb_path / "time" / "pps")
+                .set_publisher(
+                        std::bind(&time_core_3000::get_time_last_pps, _radio_perifs[0].time64));
+        _tree->access<time_spec_t>(mb_path / "time" / "pps")
+                .add_coerced_subscriber(std::bind(
+                        &ant_impl::set_time_next_pps, this, std::placeholders::_1));
+
+        // setup time source props
+        const std::vector<std::string> time_sources =
+                (_gpsdo_capable)
+                ? std::vector<std::string>{"none", "internal", "external", "gpsdo"}
+                : std::vector<std::string>{"none", "internal", "external"};
+        _tree->create<std::vector<std::string>>(mb_path / "time_source" / "options")
+                .set(time_sources);
+        _tree->create<std::string>(mb_path / "time_source" / "value")
+                .set_coercer(std::bind(
+                        &ant_check_option_valid, "time source", time_sources, std::placeholders::_1))
+                .add_coerced_subscriber(
+                        std::bind(&ant_impl::update_time_source, this, std::placeholders::_1));
+        // setup reference source props
+        const std::vector<std::string> clock_sources =
+                (_gpsdo_capable) ? std::vector<std::string>{"internal", "external", "gpsdo"}
+                                 : std::vector<std::string>{"internal", "external"};
+        _tree->create<std::vector<std::string>>(mb_path / "clock_source" / "options")
+                .set(clock_sources);
+        _tree->create<std::string>(mb_path / "clock_source" / "value")
+                .set_coercer(std::bind(
+                        &ant_check_option_valid, "clock source", clock_sources, std::placeholders::_1))
+                .add_coerced_subscriber(
+                        std::bind(&ant_impl::update_clock_source, this, std::placeholders::_1));
+
+        ////////////////////////////////////////////////////////////////////
+        // front panel gpio
+        ////////////////////////////////////////////////////////////////////
+        _radio_perifs[0].fp_gpio =
+                gpio_atr_3000::make(_radio_perifs[0].ctrl,
+                                    gpio_atr_offsets::make_default(TOREG(SR_FP_GPIO), RB32_FP_GPIO));
+        for (const auto &attr: gpio_attr_map) {
+            switch (attr.first) {
+                case usrp::gpio_atr::GPIO_SRC:
+                    _tree
+                            ->create<std::vector<std::string>>(
+                                    mb_path / "gpio" / "FP0" / attr.second)
+                            .set(std::vector<std::string>(
+                                    32, usrp::gpio_atr::default_attr_value_map.at(attr.first)))
+                            .add_coerced_subscriber([](const std::vector<std::string> &) {
+                                throw uhd::runtime_error("This device does not support setting "
+                                                         "the GPIO_SRC attribute.");
+                            });
+                    break;
+                case usrp::gpio_atr::GPIO_CTRL:
+                case usrp::gpio_atr::GPIO_DDR:
+                    _tree
+                            ->create<std::vector<std::string>>(
+                                    mb_path / "gpio" / "FP0" / attr.second)
+                            .set(std::vector<std::string>(
+                                    32, usrp::gpio_atr::default_attr_value_map.at(attr.first)))
+                            .add_coerced_subscriber([this, attr](
+                                    const std::vector<std::string> str_val) {
+                                uint32_t val = 0;
+                                for (size_t i = 0; i < str_val.size(); i++) {
+                                    val += usrp::gpio_atr::gpio_attr_value_pair.at(attr.second)
+                                            .at(str_val[i])
+                                            << i;
+                                }
+                                _radio_perifs[0].fp_gpio->set_gpio_attr(attr.first, val);
+                            });
+                    break;
+                case usrp::gpio_atr::GPIO_READBACK:
+                    _tree->create<uint32_t>(mb_path / "gpio" / "FP0" / "READBACK")
+                            .set_publisher(
+                                    std::bind(&gpio_atr_3000::read_gpio, _radio_perifs[0].fp_gpio));
+                    break;
+                default:
+                    _tree->create<uint32_t>(mb_path / "gpio" / "FP0" / attr.second)
+                            .set(0)
+                            .add_coerced_subscriber(std::bind(&gpio_atr_3000::set_gpio_attr,
+                                                              _radio_perifs[0].fp_gpio,
+                                                              attr.first,
+                                                              std::placeholders::_1));
+            }
+        }
+    }
+    ////////////////////////////////////////////////////////////////////
+    // dboard eeproms but not really
+    ////////////////////////////////////////////////////////////////////
+    dboard_eeprom_t db_eeprom;
+    _tree->create<dboard_eeprom_t>(mb_path / "dboards" / "A" / "rx_eeprom")
+        .set(db_eeprom);
+    _tree->create<dboard_eeprom_t>(mb_path / "dboards" / "A" / "tx_eeprom")
+        .set(db_eeprom);
+    _tree->create<dboard_eeprom_t>(mb_path / "dboards" / "A" / "gdb_eeprom")
+        .set(db_eeprom);
+
+    ////////////////////////////////////////////////////////////////////
+    // do some post-init tasks
+    ////////////////////////////////////////////////////////////////////
+    // Init the clock rate and the auto mcr appropriately
+    if (not device_addr.has_key("master_clock_rate")) {
+        UHD_LOGGER_INFO("ANT") << "Setting master clock rate selection to 'automatic'.";
+    }
+    // We can automatically choose a master clock rate, but not if the user specifies one
+    const double default_tick_rate =
+        device_addr.cast<double>("master_clock_rate", ad936x_manager::DEFAULT_TICK_RATE);
+    _tree->access<double>(mb_path / "tick_rate").set(default_tick_rate);
+    _tree->access<bool>(mb_path / "auto_tick_rate")
+        .set(not device_addr.has_key("master_clock_rate"));
+
+    // subdev spec contains full width of selections
+    subdev_spec_t rx_spec, tx_spec;
+    for (const std::string& fe :
+        _tree->list(mb_path / "dboards" / "A" / "rx_frontends")) {
+        rx_spec.push_back(subdev_spec_pair_t("A", fe));
+    }
+    for (const std::string& fe :
+        _tree->list(mb_path / "dboards" / "A" / "tx_frontends")) {
+        tx_spec.push_back(subdev_spec_pair_t("A", fe));
+    }
+    _tree->access<subdev_spec_t>(mb_path / "rx_subdev_spec").set(rx_spec);
+    _tree->access<subdev_spec_t>(mb_path / "tx_subdev_spec").set(tx_spec);
+
+    // init to internal clock and time source
+    _tree->access<std::string>(mb_path / "clock_source/value").set("internal");
+    _tree->access<std::string>(mb_path / "time_source/value").set("internal");
+
+    // Set the DSP chains to some safe value
+    for (size_t i = 0; i < _radio_perifs.size(); i++) {
+        _radio_perifs[i].ddc->set_host_rate(
+            default_tick_rate / ad936x_manager::DEFAULT_DECIM);
+        _radio_perifs[i].duc->set_host_rate(
+            default_tick_rate / ad936x_manager::DEFAULT_INTERP);
+    }
+}
+
+ant_impl::~ant_impl(void)
+{
+    UHD_SAFE_CALL(_async_task.reset();)
+}
+
+/***********************************************************************
+ * setup radio control objects
+ **********************************************************************/
+void ant_impl::setup_radio(const size_t dspno)
+{
+    radio_perifs_t& perif = _radio_perifs[dspno];
+    const fs_path mb_path = "/mboards/0";
+
+    ////////////////////////////////////////////////////////////////////
+    // Set up transport
+    ////////////////////////////////////////////////////////////////////
+    const uint32_t sid = (dspno == 0) ? ANT_CTRL0_MSG_SID : ANT_CTRL1_MSG_SID;
+
+    ////////////////////////////////////////////////////////////////////
+    // radio control
+    ////////////////////////////////////////////////////////////////////
+    perif.ctrl = ant_radio_ctrl_core::make(
+        false /*lilE*/, _ctrl_transport, zero_copy_if::sptr() /*null*/, sid);
+    perif.ctrl->hold_task(_async_task);
+    _async_task_data->radio_ctrl[dspno] = perif.ctrl; // weak
+    _tree->access<time_spec_t>(mb_path / "time" / "cmd")
+        .add_coerced_subscriber(std::bind(
+            &ant_radio_ctrl_core::set_time, perif.ctrl, std::placeholders::_1));
+    _tree->access<double>(mb_path / "tick_rate")
+        .add_coerced_subscriber(std::bind(
+            &ant_radio_ctrl_core::set_tick_rate, perif.ctrl, std::placeholders::_1));
+    this->register_loopback_self_test(perif.ctrl);
+
+    ////////////////////////////////////////////////////////////////////
+    // Set up peripherals
+    ////////////////////////////////////////////////////////////////////
+    perif.atr = gpio_atr_3000::make(perif.ctrl, gpio_atr_offsets::make_write_only(TOREG(SR_ATR)));
+    perif.atr->set_atr_mode(MODE_ATR, 0xFFFFFFFF);
+    // create rx dsp control objects
+    perif.framer = rx_vita_core_3000::make(perif.ctrl, TOREG(SR_RX_CTRL));
+    perif.ddc = rx_dsp_core_3000::make(perif.ctrl, TOREG(SR_RX_DSP), true /*is_ant?*/);
+    perif.ddc->set_link_rate(10e9 / 8); // whatever
+    perif.ddc->set_mux(usrp::fe_connection_t(dspno == 1 ? "IbQb" : "IQ"));
+    perif.ddc->set_freq(rx_dsp_core_3000::DEFAULT_CORDIC_FREQ);
+    perif.deframer = tx_vita_core_3000::make_no_radio_buff(perif.ctrl, TOREG(SR_TX_CTRL));
+    perif.duc      = tx_dsp_core_3000::make(perif.ctrl, TOREG(SR_TX_DSP));
+    perif.duc->set_link_rate(10e9 / 8); // whatever
+    perif.duc->set_freq(tx_dsp_core_3000::DEFAULT_CORDIC_FREQ);
+    if (_enable_user_regs) {
+        UHD_LOG_DEBUG("ANT", "Enabling user settings registers");
+        perif.user_settings = user_settings_core_3000::make(
+            perif.ctrl, TOREG(SR_USER_SR_BASE), TOREG(SR_USER_RB_ADDR));
+        if (!perif.user_settings) {
+            const std::string error_msg = "Failed to create user settings bus!";
+            UHD_LOG_ERROR("ANT", error_msg);
+            throw uhd::runtime_error(error_msg);
+        }
+    }
+
+    ////////////////////////////////////////////////////////////////////
+    // create time control objects
+    ////////////////////////////////////////////////////////////////////
+    time_core_3000::readback_bases_type time64_rb_bases;
+    time64_rb_bases.rb_now = RB64_TIME_NOW;
+    time64_rb_bases.rb_pps = RB64_TIME_PPS;
+    perif.time64 = time_core_3000::make(perif.ctrl, TOREG(SR_TIME), time64_rb_bases);
+
+    ////////////////////////////////////////////////////////////////////
+    // connect rx dsp control objects
+    ////////////////////////////////////////////////////////////////////
+    const fs_path rx_dsp_path = mb_path / "rx_dsps" / dspno;
+    perif.ddc->populate_subtree(_tree->subtree(rx_dsp_path));
+    _tree->create<bool>(rx_dsp_path / "rate" / "set").set(false);
+    _tree->access<double>(rx_dsp_path / "rate" / "value")
+        .set_coercer(std::bind(&ant_impl::coerce_rx_samp_rate,
+            this,
+            perif.ddc,
+            dspno,
+            std::placeholders::_1))
+        .add_coerced_subscriber([this, rx_dsp_path](const double) {
+            if (this->_tree) {
+                this->_tree->access<bool>(rx_dsp_path / "rate" / "set").set(true);
+            }
+        })
+        .add_coerced_subscriber(std::bind(
+            &ant_impl::update_rx_samp_rate, this, dspno, std::placeholders::_1));
+    _tree->create<stream_cmd_t>(rx_dsp_path / "stream_cmd")
+        .add_coerced_subscriber(std::bind(&rx_vita_core_3000::issue_stream_command,
+            perif.framer,
+            std::placeholders::_1));
+    _tree->access<double>(mb_path / "tick_rate")
+        .add_coerced_subscriber(std::bind(
+            &rx_vita_core_3000::set_tick_rate, perif.framer, std::placeholders::_1))
+        .add_coerced_subscriber(std::bind(&ant_impl::update_rx_dsp_tick_rate,
+            this,
+            std::placeholders::_1,
+            perif.ddc,
+            rx_dsp_path));
+
+    ////////////////////////////////////////////////////////////////////
+    // create tx dsp control objects
+    ////////////////////////////////////////////////////////////////////
+    const fs_path tx_dsp_path = mb_path / "tx_dsps" / dspno;
+    perif.duc->populate_subtree(_tree->subtree(tx_dsp_path));
+    _tree->create<bool>(tx_dsp_path / "rate" / "set").set(false);
+    _tree->access<double>(tx_dsp_path / "rate" / "value")
+        .set_coercer(std::bind(&ant_impl::coerce_tx_samp_rate,
+            this,
+            perif.duc,
+            dspno,
+            std::placeholders::_1))
+        .add_coerced_subscriber([this, tx_dsp_path](const double) {
+            if (this->_tree) {
+                this->_tree->access<bool>(tx_dsp_path / "rate" / "set").set(true);
+            }
+        })
+        .add_coerced_subscriber(std::bind(
+            &ant_impl::update_tx_samp_rate, this, dspno, std::placeholders::_1));
+    _tree->access<double>(mb_path / "tick_rate")
+        .add_coerced_subscriber(std::bind(&ant_impl::update_tx_dsp_tick_rate,
+            this,
+            std::placeholders::_1,
+            perif.duc,
+            tx_dsp_path));
+
+    ////////////////////////////////////////////////////////////////////
+    // create RF frontend interfacing
+    ////////////////////////////////////////////////////////////////////
+    // The "calibration serial" is the motherboard serial plus the frontend
+    // (A or B) separated by colon, e.g. "1234ABC:A".
+    const std::string cal_serial =
+        _tree->access<mboard_eeprom_t>(mb_path / "eeprom").get()["serial"] + "#"
+        + (dspno ? "B" : "A");
+    // The "calibration key" is either b2xxmini_power_cal_$dir_$ant, or
+    // b2xx_power_cal_$dir_$ant, depending on the form factor.
+    // $dir is either "tx" or "rx", and "ant" is either "tx_rx" or "rx2" (i.e.,
+    // sanitized version of the antenna names that work in filenames.
+    const std::string cal_key_base =
+        (_product == B200MINI or _product == B205MINI) ? "b2xxmini_pwr_" : "b2xx_pwr_";
+    for (direction_t dir : std::vector<direction_t>{RX_DIRECTION, TX_DIRECTION}) {
+        const std::string dir_key = (dir == RX_DIRECTION) ? "rx" : "tx";
+        const std::string key     = std::string(((dir == RX_DIRECTION) ? "RX" : "TX"))
+                                + std::string(((dspno == _fe1) ? "1" : "2"));
+        const fs_path rf_fe_path =
+            mb_path / "dboards" / "A" / (dir_key + "_frontends") / (dspno ? "B" : "A");
+        const std::vector<std::string> ants =
+            (dir == RX_DIRECTION) ? std::vector<std::string>{"TX/RX", "RX2"}
+                                  : std::vector<std::string>{"TX/RX"};
+
+        // This will connect all the AD936x-specific items
+        _codec_mgr->populate_frontend_subtree(_tree->subtree(rf_fe_path), key, dir);
+
+        // Antenna controls are board-specific, not AD936x specific
+        if (dir == RX_DIRECTION) {
+            _tree->create<std::string>(rf_fe_path / "antenna" / "value")
+                .add_coerced_subscriber([this, dspno](const std::string& antenna) {
+                    this->update_antenna_sel(dspno, antenna);
+                })
+                .set("RX2");
+        } else if (dir == TX_DIRECTION) {
+            _tree->create<std::string>(rf_fe_path / "antenna" / "value").set("TX/RX");
+        }
+
+        // We don't add any baseband correction
+        auto ggroup                    = uhd::gain_group::make();
+        constexpr char HW_GAIN_STAGE[] = "hw";
+        ggroup->register_fcns(HW_GAIN_STAGE,
+            {// Get gain range:
+                [key]() { return ad9361_ctrl::get_gain_range(key); },
+                // Get gain:
+                [this, rf_fe_path, key]() {
+                    return _tree
+                        ->access<double>(rf_fe_path / "gains"
+                                         / ad9361_ctrl::get_gain_names(key).at(0)
+                                         / "value")
+                        .get();
+                },
+                // Set gain:
+                [this, rf_fe_path, key](const double gain) {
+                    _tree
+                        ->access<double>(rf_fe_path / "gains"
+                                         / ad9361_ctrl::get_gain_names(key).at(0)
+                                         / "value")
+                        .set(gain);
+                }});
+        // Add power controls
+        perif.pwr_mgr.insert({dir_key,
+            pwr_cal_mgr::make(
+                cal_serial,
+                "ANT-CAL-" + key,
+                // Frequency getter:
+                [this, rf_fe_path]() {
+                    return _tree->access<double>(rf_fe_path / "freq" / "value").get();
+                },
+                // Current key getter (see notes on calibration key above):
+                [this, rf_fe_path, cal_key_base, dir_key]() {
+                    return cal_key_base + dir_key + "_"
+                           + pwr_cal_mgr::sanitize_antenna_name(
+                               _tree->access<std::string>(
+                                        rf_fe_path / "antenna" / "value")
+                                   .get());
+                },
+                ggroup)});
+        perif.pwr_mgr.at(dir_key)->populate_subtree(_tree->subtree(rf_fe_path));
+        perif.pwr_mgr.at(dir_key)->set_temperature(
+            _tree->access<sensor_value_t>(rf_fe_path / "sensors" / "temp")
+                .get()
+                .to_int());
+
+        // Now connect all the ant_impl-specific items
+        _tree->create<sensor_value_t>(rf_fe_path / "sensors" / "lo_locked")
+            .set_publisher(
+                [this, dir]() { return this->get_fe_pll_locked(dir == TX_DIRECTION); });
+        _tree->access<double>(rf_fe_path / "freq" / "value")
+            .add_coerced_subscriber([this, key](const double freq) {
+                return this->update_bandsel(key, freq);
+            })
+            // Every time we retune, we re-set the power level.
+            .add_coerced_subscriber([pwr_mgr = perif.pwr_mgr.at(dir_key)](
+                                        const double) { pwr_mgr->update_power(); })
+
+            ;
+        _tree->create<std::vector<std::string>>(rf_fe_path / "antenna" / "options")
+            .set(ants);
+        // When we set the gain, we need to disable power tracking. Note that
+        // the power manager also calls into the gains property, and thus
+        // clobbers its own tracking mode, but that's OK because set_power() will
+        // always reset the tracking mode.
+        _tree
+            ->access<double>(
+                rf_fe_path / "gains" / ad9361_ctrl::get_gain_names(key).at(0) / "value")
+            .add_coerced_subscriber([pwr_mgr = perif.pwr_mgr.at(dir_key)](const double) {
+                pwr_mgr->set_tracking_mode(pwr_cal_mgr::tracking_mode::TRACK_GAIN);
+            });
+
+        if (_enable_user_regs) {
+            _tree->create<uhd::wb_iface::sptr>(rf_fe_path / "user_settings/iface")
+                .set(perif.user_settings);
+        }
+    }
+}
+
+/***********************************************************************
+ * loopback tests
+ **********************************************************************/
+
+void ant_impl::register_loopback_self_test(wb_iface::sptr iface)
+{
+    bool test_fail = false;
+    UHD_LOGGER_INFO("ANT") << "Performing register loopback test... ";
+    size_t hash = size_t(time(NULL));
+    for (size_t i = 0; i < 100; i++) {
+        boost::hash_combine(hash, i);
+        iface->poke32(TOREG(SR_TEST), uint32_t(hash));
+        test_fail = iface->peek32(RB32_TEST) != uint32_t(hash);
+        if (test_fail)
+            break; // exit loop on any failure
+    }
+    UHD_LOGGER_INFO("ANT") << "Register loopback test "
+                            << ((test_fail) ? "failed" : "passed");
+}
+
+/***********************************************************************
+ * Sample and tick rate comprehension below
+ **********************************************************************/
+void ant_impl::enforce_tick_rate_limits(
+    size_t chan_count, double tick_rate, const std::string& direction /*= ""*/)
+{
+    const size_t max_chans = 2;
+    if (chan_count > max_chans) {
+        throw uhd::value_error(boost::str(
+            boost::format("cannot not setup %d %s channels (maximum is %d)") % chan_count
+            % (direction.empty() ? "data" : direction) % max_chans));
+    } else {
+        const double max_tick_rate =
+            ad9361_device_t::AD9361_MAX_CLOCK_RATE / ((chan_count <= 1) ? 1 : 2);
+        if (tick_rate - max_tick_rate >= 1.0) {
+            throw uhd::value_error(boost::str(
+                boost::format(
+                    "current master clock rate (%.6f MHz) exceeds maximum possible "
+                    "master clock rate (%.6f MHz) when using %d %s channels")
+                % (tick_rate / 1e6) % (max_tick_rate / 1e6) % chan_count
+                % (direction.empty() ? "data" : direction)));
+        }
+        const double min_tick_rate =
+            ad9361_device_t::AD9361_MIN_CLOCK_RATE / ((chan_count <= 1) ? 1 : 2);
+        if (min_tick_rate - tick_rate >= 1.0) {
+            throw uhd::value_error(boost::str(
+                boost::format(
+                    "current master clock rate (%.6f MHz) is less than minimum possible "
+                    "master clock rate (%.6f MHz) when using %d %s channels")
+                % (tick_rate / 1e6) % (min_tick_rate / 1e6) % chan_count
+                % (direction.empty() ? "data" : direction)));
+        }
+    }
+}
+
+double ant_impl::set_tick_rate(const double new_tick_rate)
+{
+    UHD_LOGGER_INFO("ANT") << (boost::format("Asking for clock rate %.6f MHz... ")
+                                % (new_tick_rate / 1e6))
+                            << std::flush;
+    check_tick_rate_with_current_streamers(new_tick_rate); // Defined in ant_io_impl.cpp
+
+    // Make sure the clock rate is actually changed before doing
+    // the full Monty of setting regs and loopback tests etc.
+    if (std::abs(new_tick_rate - _tick_rate) < 1.0) {
+        UHD_LOGGER_INFO("ANT") << "OK";
+        return _tick_rate;
+    }
+
+    _tick_rate = _codec_ctrl->set_clock_rate(new_tick_rate);
+    UHD_LOGGER_INFO("ANT") << (boost::format("Actually got clock rate %.6f MHz.")
+                                % (_tick_rate / 1e6));
+
+    for (radio_perifs_t& perif : _radio_perifs) {
+        perif.time64->set_tick_rate(_tick_rate);
+        perif.time64->self_test();
+    }
+    return _tick_rate;
+}
+
+/***********************************************************************
+ * compat checks
+ **********************************************************************/
+
+void ant_impl::check_fpga_compat(void)
+{
+    const uint64_t compat       = _local_ctrl->peek64(0);
+    const uint32_t signature    = uint32_t(compat >> 32);
+    const uint16_t compat_major = uint16_t(compat >> 16);
+    const uint16_t compat_minor = uint16_t(compat & 0xffff);
+    if (signature != 0xACE0BA5E)
+        throw uhd::runtime_error(
+            "ant::check_fpga_compat signature register readback failed");
+
+    const uint16_t expected = ((_product == B200MINI or _product == B205MINI)
+                                   ? B205_FPGA_COMPAT_NUM
+                                   : ANT_FPGA_COMPAT_NUM);
+    if (compat_major != expected) {
+        throw uhd::runtime_error(str(
+            boost::format("Expected FPGA compatibility number %d, but got %d:\n"
+                          "The FPGA build is not compatible with the host code build.\n"
+                          "%s")
+            % int(expected) % compat_major
+            % print_utility_error("uhd_images_downloader.py")));
+    }
+    _tree->create<std::string>("/mboards/0/fpga_version")
+        .set(str(boost::format("%u.%u") % compat_major % compat_minor));
+}
+
+/***********************************************************************
+ * Reference time and clock
+ **********************************************************************/
+
+void ant_impl::update_clock_source(const std::string& source)
+{
+    // For B205, ref_sel selects whether or not to lock to the external clock source
+    if (_product == B200MINI or _product == B205MINI) {
+        if (source == "external" and _time_source == EXTERNAL) {
+            throw uhd::value_error(
+                "external reference cannot be both a clock source and a time source");
+        }
+
+        if (source == "internal") {
+            if (_gpio_state.ref_sel != 0) {
+                _gpio_state.ref_sel = 0;
+                this->update_gpio_state();
+            }
+        } else if (source == "external") {
+            if (_gpio_state.ref_sel != 1) {
+                _gpio_state.ref_sel = 1;
+                this->update_gpio_state();
+            }
+        } else {
+            throw uhd::key_error("update_clock_source: unknown source: " + source);
+        }
+        return;
+    }
+
+    // For all other devices, ref_sel selects the external or gpsdo clock source
+    // and the ADF4001 selects whether to lock to it or not
+    if (source == "internal") {
+        _adf4001_iface->set_lock_to_ext_ref(false);
+    } else if (source == "external") {
+        if (_gpio_state.ref_sel != 0) {
+            _gpio_state.ref_sel = 0;
+            this->update_gpio_state();
+        }
+        _adf4001_iface->set_lock_to_ext_ref(true);
+    } else if (source == "gpsdo") {
+        if (not _gps or not _gps->gps_detected()) {
+            throw uhd::key_error(
+                "update_clock_source: gpsdo selected, but no gpsdo detected!");
+        }
+        if (_gpio_state.ref_sel != 1) {
+            _gpio_state.ref_sel = 1;
+            this->update_gpio_state();
+        }
+        _adf4001_iface->set_lock_to_ext_ref(true);
+    } else {
+        throw uhd::key_error("update_clock_source: unknown source: " + source);
+    }
+}
+
+void ant_impl::update_time_source(const std::string& source)
+{
+    if ((_product == B200MINI or _product == B205MINI) and source == "external"
+        and _gpio_state.ref_sel == 1) {
+        throw uhd::value_error(
+            "external reference cannot be both a time source and a clock source");
+    }
+
+    // We assume source is valid for this device (if it's gone through
+    // the prop three, then it definitely is thanks to our coercer)
+    time_source_t value;
+    if (source == "none")
+        value = NONE;
+    else if (source == "internal")
+        value = INTERNAL;
+    else if (source == "external")
+        value = EXTERNAL;
+    else if (_gps and source == "gpsdo")
+        value = GPSDO;
+    else
+        throw uhd::key_error("update_time_source: unknown source: " + source);
+    if (_time_source != value) {
+        _local_ctrl->poke32(TOREG(SR_CORE_SYNC), value);
+        _time_source = value;
+    }
+}
+
+void ant_impl::set_time(const uhd::time_spec_t& t)
+{
+    for (radio_perifs_t& perif : _radio_perifs)
+        perif.time64->set_time_sync(t);
+    _local_ctrl->poke32(TOREG(SR_CORE_SYNC), 1 << 2 | uint32_t(_time_source));
+    _local_ctrl->poke32(TOREG(SR_CORE_SYNC), _time_source);
+    _time_set_with_pps = false;
+}
+
+void ant_impl::set_time_next_pps(const uhd::time_spec_t& t)
+{
+    for (radio_perifs_t& perif : _radio_perifs)
+        perif.time64->set_time_next_pps(t);
+    _time_set_with_pps = true;
+}
+
+void ant_impl::sync_times()
+{
+    if (_time_set_with_pps) {
+        UHD_LOG_DEBUG("ANT", "Re-synchronizing time using PPS");
+        uhd::time_spec_t time_last_pps = _radio_perifs[0].time64->get_time_last_pps();
+        while (_radio_perifs[0].time64->get_time_last_pps() == time_last_pps) {
+            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        }
+        set_time_next_pps(time_last_pps + 2.0);
+    } else {
+        set_time(_radio_perifs[0].time64->get_time_now());
+    }
+}
+
+/***********************************************************************
+ * GPIO setup
+ **********************************************************************/
+
+void ant_impl::update_bandsel(const std::string& which, double freq)
+{
+    // B205 does not have bandsels
+    if (_product == B200MINI or _product == B205MINI) {
+        return;
+    }
+
+    if (which[0] == 'R') {
+        if (freq < 2.2e9) {
+            _gpio_state.rx_bandsel_a = 0;
+            _gpio_state.rx_bandsel_b = 0;
+            _gpio_state.rx_bandsel_c = 1;
+        } else if ((freq >= 2.2e9) && (freq < 4e9)) {
+            _gpio_state.rx_bandsel_a = 0;
+            _gpio_state.rx_bandsel_b = 1;
+            _gpio_state.rx_bandsel_c = 0;
+        } else if ((freq >= 4e9) && (freq <= 6e9)) {
+            _gpio_state.rx_bandsel_a = 1;
+            _gpio_state.rx_bandsel_b = 0;
+            _gpio_state.rx_bandsel_c = 0;
+        } else {
+            UHD_THROW_INVALID_CODE_PATH();
+        }
+    } else if (which[0] == 'T') {
+        if (freq < 2.5e9) {
+            _gpio_state.tx_bandsel_a = 0;
+            _gpio_state.tx_bandsel_b = 1;
+        } else if ((freq >= 2.5e9) && (freq <= 6e9)) {
+            _gpio_state.tx_bandsel_a = 1;
+            _gpio_state.tx_bandsel_b = 0;
+        } else {
+            UHD_THROW_INVALID_CODE_PATH();
+        }
+    } else {
+        UHD_THROW_INVALID_CODE_PATH();
+    }
+
+    update_gpio_state();
+}
+
+void ant_impl::reset_codec()
+{
+    _gpio_state.codec_arst = 1;
+    update_gpio_state();
+    _gpio_state.codec_arst = 0;
+    update_gpio_state();
+}
+
+void ant_impl::update_gpio_state(void)
+{
+    const uint32_t misc_word =
+        0 | (_gpio_state.swap_atr << 8) | (_gpio_state.tx_bandsel_a << 7)
+        | (_gpio_state.tx_bandsel_b << 6) | (_gpio_state.rx_bandsel_a << 5)
+        | (_gpio_state.rx_bandsel_b << 4) | (_gpio_state.rx_bandsel_c << 3)
+        | (_gpio_state.codec_arst << 2) | (_gpio_state.mimo << 1)
+        | (_gpio_state.ref_sel << 0);
+
+    _local_ctrl->poke32(TOREG(SR_CORE_MISC), misc_word);
+}
+
+void ant_impl::update_atrs(void)
+{
+    if (_radio_perifs.size() > _fe1 and _radio_perifs[_fe1].atr) {
+        radio_perifs_t& perif = _radio_perifs[_fe1];
+        const bool enb_rx     = bool(perif.rx_streamer.lock());
+        const bool enb_tx     = bool(perif.tx_streamer.lock());
+        const bool is_rx2     = perif.ant_rx2;
+        const uint32_t rxonly = (enb_rx) ? ((is_rx2) ? STATE_RX1_RX2 : STATE_RX1_TXRX)
+                                         : STATE_OFF;
+        const uint32_t txonly = (enb_tx) ? (STATE_TX1_TXRX) : STATE_OFF;
+        uint32_t fd           = STATE_OFF;
+        if (enb_rx and enb_tx)
+            fd = STATE_FDX1_TXRX;
+        if (enb_rx and not enb_tx)
+            fd = rxonly;
+        if (not enb_rx and enb_tx)
+            fd = txonly;
+        gpio_atr_3000::sptr atr = perif.atr;
+        atr->set_atr_reg(ATR_REG_IDLE, STATE_OFF);
+        atr->set_atr_reg(ATR_REG_RX_ONLY, rxonly);
+        atr->set_atr_reg(ATR_REG_TX_ONLY, txonly);
+        atr->set_atr_reg(ATR_REG_FULL_DUPLEX, fd);
+    }
+    if (_radio_perifs.size() > _fe2 and _radio_perifs[_fe2].atr) {
+        radio_perifs_t& perif = _radio_perifs[_fe2];
+        const bool enb_rx     = bool(perif.rx_streamer.lock());
+        const bool enb_tx     = bool(perif.tx_streamer.lock());
+        const bool is_rx2     = perif.ant_rx2;
+        const uint32_t rxonly = (enb_rx) ? ((is_rx2) ? STATE_RX2_RX2 : STATE_RX2_TXRX)
+                                         : STATE_OFF;
+        const uint32_t txonly = (enb_tx) ? (STATE_TX2_TXRX) : STATE_OFF;
+        uint32_t fd           = STATE_OFF;
+        if (enb_rx and enb_tx)
+            fd = STATE_FDX2_TXRX;
+        if (enb_rx and not enb_tx)
+            fd = rxonly;
+        if (not enb_rx and enb_tx)
+            fd = txonly;
+        gpio_atr_3000::sptr atr = perif.atr;
+        atr->set_atr_reg(ATR_REG_IDLE, STATE_OFF);
+        atr->set_atr_reg(ATR_REG_RX_ONLY, rxonly);
+        atr->set_atr_reg(ATR_REG_TX_ONLY, txonly);
+        atr->set_atr_reg(ATR_REG_FULL_DUPLEX, fd);
+    }
+}
+
+void ant_impl::update_antenna_sel(const size_t which, const std::string& ant)
+{
+    if (ant != "TX/RX" and ant != "RX2")
+        throw uhd::value_error("ant: unknown RX antenna option: " + ant);
+    _radio_perifs[which].ant_rx2 = (ant == "RX2");
+    this->update_atrs();
+}
+
+void ant_impl::update_enables(void)
+{
+    // extract settings from state variables
+    const bool enb_tx1 = (_radio_perifs.size() > _fe1)
+                         and bool(_radio_perifs[_fe1].tx_streamer.lock());
+    const bool enb_rx1 = (_radio_perifs.size() > _fe1)
+                         and bool(_radio_perifs[_fe1].rx_streamer.lock());
+    const bool enb_tx2 = (_radio_perifs.size() > _fe2)
+                         and bool(_radio_perifs[_fe2].tx_streamer.lock());
+    const bool enb_rx2 = (_radio_perifs.size() > _fe2)
+                         and bool(_radio_perifs[_fe2].rx_streamer.lock());
+    const size_t num_rx = (enb_rx1 ? 1 : 0) + (enb_rx2 ? 1 : 0);
+    const size_t num_tx = (enb_tx1 ? 1 : 0) + (enb_tx2 ? 1 : 0);
+    const uint32_t mimo = (num_rx == 2 or num_tx == 2) ? 1 : 0;
+
+    if ((num_rx + num_tx) == 3) {
+        throw uhd::runtime_error(
+            "ant: 2 RX 1 TX and 1 RX 2 TX configurations not possible");
+    }
+
+    // setup the active chains in the codec
+    _codec_ctrl->set_active_chains(enb_tx1, enb_tx2, enb_rx1, enb_rx2);
+    if ((num_rx + num_tx) == 0)
+        _codec_ctrl->set_active_chains(true, false, true, false); // enable something
+
+    // update MIMO state and re-sync times if necessary
+    if (_gpio_state.mimo != mimo) {
+        _gpio_state.mimo = mimo;
+        update_gpio_state();
+        sync_times();
+    }
+
+    // atrs change based on enables
+    this->update_atrs();
+}
+
+/* microphase
+ * Thiunction is just send 8 bytes to
+ * let the fpga konw the which port
+ * it should send
+ * */
+void ant_impl::_program_dispatcher(uhd::transport::zero_copy_if &xport)
+{
+    transport::managed_send_buffer::sptr buff = xport.get_send_buff();
+    buff->cast<uint32_t *>()[0]             =0;
+    buff->cast<uint32_t *>()[1]              =uhd::htonx<uint32_t>(MICROPHASE_DATA_RX_WAZZUP_BR0);
+    buff->commit(8);
+    buff.reset();
+}
+
+sensor_value_t ant_impl::get_ref_locked(void)
+{
+    const bool lock = (_local_ctrl->peek32(RB32_CORE_MISC) & 0x1) == 0x1;
+    return sensor_value_t("Ref", lock, "locked", "unlocked");
+}
+
+sensor_value_t ant_impl::get_fe_pll_locked(const bool is_tx)
+{
+    const uint32_t st = _local_ctrl->peek32(RB32_CORE_PLL);
+    const bool locked = is_tx ? ((st & 0x1) > 0) : ((st & 0x2) > 0);
+    return sensor_value_t("LO", locked, "locked", "unlocked");
+}
+
+void ant_impl::set_mb_eeprom()
+{
+    /* we need do no things */
+}
diff --git a/host/lib/usrp/ant/ant_impl.hpp b/host/lib/usrp/ant/ant_impl.hpp
new file mode 100644
index 000000000..cdcc5b0d7
--- /dev/null
+++ b/host/lib/usrp/ant/ant_impl.hpp
@@ -0,0 +1,414 @@
+//
+// Copyright 2012-2015 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#ifndef INCLUDED_ANT_IMPL_HPP
+#define INCLUDED_ANT_IMPL_HPP
+
+#include "ant_cores.hpp"
+#include "ant_radio_ctrl_core.hpp"
+#include "ant_uart.hpp"
+#include <uhd/device.hpp>
+#include <uhd/property_tree.hpp>
+#include <uhd/transport/bounded_buffer.hpp>
+#include <uhd/transport/usb_zero_copy.hpp>
+#include <uhd/types/dict.hpp>
+#include <uhd/types/sensors.hpp>
+#include <uhd/types/stream_cmd.hpp>
+#include <uhd/usrp/gps_ctrl.hpp>
+#include <uhd/usrp/mboard_eeprom.hpp>
+#include <uhd/usrp/subdev_spec.hpp>
+#include <uhd/utils/pimpl.hpp>
+#include <uhd/utils/tasks.hpp>
+#include <uhdlib/usrp/common/ad9361_ctrl.hpp>
+#include <uhdlib/usrp/common/ad936x_manager.hpp>
+#include <uhdlib/usrp/common/adf4001_ctrl.hpp>
+#include <uhdlib/usrp/common/pwr_cal_mgr.hpp>
+#include <uhdlib/usrp/common/recv_packet_demuxer_3000.hpp>
+#include <uhdlib/usrp/cores/gpio_atr_3000.hpp>
+#include <uhdlib/usrp/cores/rx_dsp_core_3000.hpp>
+#include <uhdlib/usrp/cores/rx_vita_core_3000.hpp>
+#include <uhdlib/usrp/cores/time_core_3000.hpp>
+#include <uhdlib/usrp/cores/tx_dsp_core_3000.hpp>
+#include <uhdlib/usrp/cores/tx_vita_core_3000.hpp>
+#include <uhdlib/usrp/cores/user_settings_core_3000.hpp>
+#include <unordered_map>
+#include <boost/assign.hpp>
+#include <boost/function.hpp>
+#include <memory>
+#include <mutex>
+#include <unordered_map>
+/* microphase */
+#include "uhd/transport/udp_simple.hpp"
+#include "uhd/transport/udp_zero_copy.hpp"
+#include "uhd/transport/vrt_if_packet.hpp"
+
+/* microphase */
+/*
+ * UDP ports for the E310 communication
+ * ports 49200 - 49210
+ * */
+
+/* microphase */
+enum microphase_produce_t {E310 ,E200 ,ETTUS};
+
+enum b200_product_t { ANT, B200, B210, B200MINI, B205MINI };
+
+#define MICROPHASE_ANT_UDP_FIND_PORT 49100
+#define MICROPHASE_ANT_UDP_CTRL_PORT 49200
+#define MICROPHASE_ANT_UDP_DATA_TX_PORT 49202
+#define MICROPHASE_ANT_UDP_DATA_TX1_PORT 49203
+#define MICROPHASE_ANT_UDP_DATA_RX_PORT 49204
+
+#define MICROPHASE_ANT_FW_COMPAT_NUM 2
+
+#define BUFF_SIZE 1e6
+
+
+typedef enum{
+    MICROPHASE_CHECK = '1',
+
+    MICROPHASE_CTRL_ID_WAZZUP_BR0 = 'm',
+    MICROPHASE_CTRL_ID_WAZZUP_DUDE = 'M',
+
+    MICROPHASE_SERIAL_BR0 = '9',
+    MICROPHASE_SERIAL_DUDE = '0',
+
+    MICROPHASE_AUTHOR_BR0 = 'j',
+    MICROPHASE_AUTHOR_DUDE = 'c',
+
+    MICROPHASE_DATA_RX_WAZZUP_BR0 = 'r',
+} microphase_ant_ctrl_id_e;
+
+typedef struct {
+    uint32_t check;
+    uint32_t id;
+    uint32_t serial;
+    uint32_t auth;
+    uint8_t serial_all[32];
+    uint8_t board_version[8];
+} microphase_ant_ctrl_data_t;
+
+static const uint8_t ANT_FW_COMPAT_NUM_MAJOR = 8;
+static const uint8_t ANT_FW_COMPAT_NUM_MINOR = 0;
+static const uint16_t ANT_FPGA_COMPAT_NUM    = 16;
+static const uint16_t B205_FPGA_COMPAT_NUM    = 7;
+static const double ANT_BUS_CLOCK_RATE       = 100e6;
+static const uint32_t ANT_GPSDO_ST_NONE      = 0x83;
+static constexpr double ANT_MAX_RATE_USB2    = 53248000; // bytes/s
+static constexpr double ANT_MAX_RATE_USB3    = 500000000; // bytes/s
+
+#define FLIP_SID(sid) (((sid) << 16) | ((sid) >> 16))
+
+static const uint32_t ANT_CTRL0_MSG_SID = 0x00000010;
+static const uint32_t ANT_RESP0_MSG_SID = FLIP_SID(ANT_CTRL0_MSG_SID);
+
+static const uint32_t ANT_CTRL1_MSG_SID = 0x00000020;
+static const uint32_t ANT_RESP1_MSG_SID = FLIP_SID(ANT_CTRL1_MSG_SID);
+
+static const uint32_t ANT_TX_DATA0_SID = 0x00000050;
+static const uint32_t ANT_TX_MSG0_SID  = FLIP_SID(ANT_TX_DATA0_SID);
+
+static const uint32_t ANT_TX_DATA1_SID = 0x00000060;
+static const uint32_t ANT_TX_MSG1_SID  = FLIP_SID(ANT_TX_DATA1_SID);
+
+static const uint32_t ANT_RX_DATA0_SID = 0x000000A0;
+static const uint32_t ANT_RX_DATA1_SID = 0x000000B0;
+
+static const uint32_t ANT_TX_GPS_UART_SID = 0x00000030;
+static const uint32_t ANT_RX_GPS_UART_SID = FLIP_SID(ANT_TX_GPS_UART_SID);
+
+static const uint32_t ANT_LOCAL_CTRL_SID = 0x00000040;
+static const uint32_t ANT_LOCAL_RESP_SID = FLIP_SID(ANT_LOCAL_CTRL_SID);
+
+/*static const unsigned char ANT_USB_CTRL_RECV_INTERFACE = 4;
+static const unsigned char ANT_USB_CTRL_RECV_ENDPOINT  = 8;
+static const unsigned char ANT_USB_CTRL_SEND_INTERFACE = 3;
+static const unsigned char ANT_USB_CTRL_SEND_ENDPOINT  = 4;
+
+static const unsigned char ANT_USB_DATA_RECV_INTERFACE = 2;
+static const unsigned char ANT_USB_DATA_RECV_ENDPOINT  = 6;
+static const unsigned char ANT_USB_DATA_SEND_INTERFACE = 1;
+static const unsigned char ANT_USB_DATA_SEND_ENDPOINT  = 2;
+
+// Default recv_frame_size. Must not be a multiple of 512.
+static const int ANT_USB_DATA_DEFAULT_FRAME_SIZE = 8176;
+// recv_frame_size values below this will be upped to this value
+static const int ANT_USB_DATA_MIN_RECV_FRAME_SIZE = 40;
+static const int ANT_USB_DATA_MAX_RECV_FRAME_SIZE = 16360;
+
+static std::vector<uhd::transport::usb_device_handle::vid_pid_pair_t> ant_vid_pid_pairs =
+    boost::assign::list_of(uhd::transport::usb_device_handle::vid_pid_pair_t(
+        ANT_VENDOR_ID, ANT_PRODUCT_ID))(
+        uhd::transport::usb_device_handle::vid_pid_pair_t(
+            ANT_VENDOR_ID, ANT_PRODUCT_ID));
+
+b200_product_t get_ant_product(const uhd::transport::usb_device_handle::sptr& handle,
+    const uhd::usrp::mboard_eeprom_t& mb_eeprom);
+std::vector<uhd::transport::usb_device_handle::sptr> get_ant_device_handles(
+    const uhd::device_addr_t& hint);*/
+
+//! Implementation guts
+class ant_impl : public uhd::device
+{
+public:
+    // structors
+    ant_impl(const uhd::device_addr_t&);
+    ~ant_impl(void) override;
+
+    // the io interface
+    uhd::rx_streamer::sptr get_rx_stream(const uhd::stream_args_t& args) override;
+    uhd::tx_streamer::sptr get_tx_stream(const uhd::stream_args_t& args) override;
+    bool recv_async_msg(uhd::async_metadata_t&, double) override;
+
+    //! Check that the combination of stream args and tick rate are valid.
+    //
+    // Basically figures out the arguments for enforce_tick_rate_limits()
+    // and calls said method. If arguments are invalid, throws a
+    // uhd::value_error.
+    void check_streamer_args(const uhd::stream_args_t& args,
+        double tick_rate,
+        const std::string& direction = "");
+
+    static uhd::usrp::mboard_eeprom_t get_mb_eeprom(uhd::i2c_iface::sptr);
+
+private:
+    /* microphase product */
+    microphase_produce_t _product_mp;
+    b200_product_t _product;
+    size_t _revision;
+    bool _gpsdo_capable;
+    //! This flag is true if the FPGA has custom (user) registers and access to
+    // those needs to be enabled from software.
+    const bool _enable_user_regs;
+
+    // controllers
+    ant_radio_ctrl_core::sptr _local_ctrl;
+    uhd::usrp::ad9361_ctrl::sptr _codec_ctrl;
+    uhd::usrp::ad936x_manager::sptr _codec_mgr;
+    ant_local_spi_core::sptr _spi_iface;
+    std::shared_ptr<uhd::usrp::adf4001_ctrl> _adf4001_iface;
+    uhd::gps_ctrl::sptr _gps;
+
+    /* microphase */
+    uhd::transport::zero_copy_if::sptr _data_tx_transport;
+    uhd::transport::zero_copy_if::sptr _data_tx1_transport;
+    uhd::transport::zero_copy_if::sptr _data_rx_transport;
+
+    // transports
+    uhd::transport::zero_copy_if::sptr _ctrl_transport;
+    uhd::usrp::recv_packet_demuxer_3000::sptr _demux;
+
+    std::weak_ptr<uhd::rx_streamer> _rx_streamer;
+    std::weak_ptr<uhd::tx_streamer> _tx_streamer;
+
+    std::mutex _transport_setup_mutex;
+
+    // async ctrl + msgs
+    uhd::msg_task::sptr _async_task;
+    typedef uhd::transport::bounded_buffer<uhd::async_metadata_t> async_md_type;
+    struct AsyncTaskData
+    {
+        std::shared_ptr<async_md_type> async_md;
+        std::weak_ptr<ant_radio_ctrl_core> local_ctrl;
+        std::weak_ptr<ant_radio_ctrl_core> radio_ctrl[2];
+        ant_uart::sptr gpsdo_uart;
+    };
+    std::shared_ptr<AsyncTaskData> _async_task_data;
+    boost::optional<uhd::msg_task::msg_type_t> handle_async_task(
+        uhd::transport::zero_copy_if::sptr, std::shared_ptr<AsyncTaskData>);
+
+    void register_loopback_self_test(uhd::wb_iface::sptr iface);
+    void set_mb_eeprom();
+    void check_fw_compat(void);
+    void check_fpga_compat(void);
+    uhd::usrp::subdev_spec_t coerce_subdev_spec(const uhd::usrp::subdev_spec_t&);
+    void update_subdev_spec(const std::string& tx_rx, const uhd::usrp::subdev_spec_t&);
+    void update_time_source(const std::string&);
+    void set_time(const uhd::time_spec_t&);
+    void set_time_next_pps(const uhd::time_spec_t&);
+    void sync_times(void);
+    void update_clock_source(const std::string&);
+    void update_bandsel(const std::string& which, double freq);
+    void reset_codec(void);
+    void update_antenna_sel(const size_t which, const std::string& ant);
+    uhd::sensor_value_t get_ref_locked(void);
+    uhd::sensor_value_t get_fe_pll_locked(const bool is_tx);
+
+    // perifs in the radio core
+    struct radio_perifs_t
+    {
+        ant_radio_ctrl_core::sptr ctrl;
+        uhd::usrp::gpio_atr::gpio_atr_3000::sptr atr;
+        uhd::usrp::gpio_atr::gpio_atr_3000::sptr fp_gpio;
+        time_core_3000::sptr time64;
+        rx_vita_core_3000::sptr framer;
+        rx_dsp_core_3000::sptr ddc;
+        tx_vita_core_3000::sptr deframer;
+        tx_dsp_core_3000::sptr duc;
+        std::weak_ptr<uhd::rx_streamer> rx_streamer;
+        std::weak_ptr<uhd::tx_streamer> tx_streamer;
+        user_settings_core_3000::sptr user_settings;
+        bool ant_rx2;
+        std::unordered_map<std::string, uhd::usrp::pwr_cal_mgr::sptr> pwr_mgr;
+    };
+    std::vector<radio_perifs_t> _radio_perifs;
+
+    // mapping of AD936x frontends (FE1 and FE2) to radio perif index (0 and 1)
+    // FE1 corresponds to the ports labeled "RF B" on the ANT
+    // FE2 corresponds to the ports labeled "RF A" on the ANT
+    // the mapping is product and revision specific
+    size_t _fe1;
+    size_t _fe2;
+
+    /*! \brief Setup the DSP chain for one radio front-end.
+     *
+     */
+    void setup_radio(const size_t radio_index);
+    void handle_overflow(const size_t radio_index);
+
+    struct gpio_state
+    {
+        uint32_t tx_bandsel_a, tx_bandsel_b, rx_bandsel_a, rx_bandsel_b, rx_bandsel_c,
+            codec_arst, mimo, ref_sel, swap_atr;
+
+        gpio_state()
+        {
+            tx_bandsel_a = 0;
+            tx_bandsel_b = 0;
+            rx_bandsel_a = 0;
+            rx_bandsel_b = 0;
+            rx_bandsel_c = 0;
+            codec_arst   = 0;
+            mimo         = 0;
+            ref_sel      = 0;
+            swap_atr     = 0;
+        }
+    } _gpio_state;
+
+    enum time_source_t {
+        GPSDO    = 0,
+        EXTERNAL = 1,
+        INTERNAL = 2,
+        NONE     = 3,
+        UNKNOWN  = 4
+    } _time_source;
+    bool _time_set_with_pps;
+
+    void update_gpio_state(void);
+
+    void update_enables(void);
+    void update_atrs(void);
+
+    double _tick_rate;
+    double get_tick_rate(void)
+    {
+        return _tick_rate;
+    }
+    double set_tick_rate(const double rate);
+
+    /*! \brief Choose a tick rate (master clock rate) that works well for the given
+     * sampling rate.
+     *
+     * This function will try and choose a master clock rate automatically.
+     * See the function definition for details on the algorithm.
+     *
+     * The chosen tick rate is the largest multiple of two that is smaler
+     * than the max tick rate.
+     * The base rate is either given explicitly, or is the lcm() of the tx
+     * and rx sampling rates. In that case, it reads the rates directly
+     * from the property tree. It also tries to guess the number of channels
+     * (for the max possible tick rate) by checking the available streamers.
+     * This value, too, can explicitly be given.
+     *
+     * \param rate If this is given, it will be used as a minimum rate, or
+     *             argument to lcm().
+     * \param tree_dsp_path The sampling rate from this property tree path
+     *                      will be ignored.
+     * \param num_chans If given, specifies the number of channels.
+     */
+    void set_auto_tick_rate(const double rate = 0,
+        const uhd::fs_path& tree_dsp_path     = "",
+        size_t num_chans                      = 0);
+
+    void update_tick_rate(const double);
+
+    /*! Subscriber to the tick_rate property, updates DDCs after tick rate change.
+     */
+    void update_rx_dsp_tick_rate(
+        const double, rx_dsp_core_3000::sptr, uhd::fs_path rx_dsp_path);
+
+    /*! Subscriber to the tick_rate property, updates DUCs after tick rate change.
+     */
+    void update_tx_dsp_tick_rate(
+        const double, tx_dsp_core_3000::sptr, uhd::fs_path tx_dsp_path);
+
+    /*! Check if \p tick_rate works with \p chan_count channels.
+     *
+     * Throws a uhd::value_error if not.
+     */
+    void enforce_tick_rate_limits(
+        size_t chan_count, double tick_rate, const std::string& direction = "");
+    void check_tick_rate_with_current_streamers(double rate);
+
+    /*! Return the max number of channels on active rx_streamer or tx_streamer objects
+     * associated with this device.
+     *
+     * \param direction Set to "TX" to only check tx_streamers, "RX" to only check
+     *                  rx_streamers. Any other value will check if \e any active
+     *                  streamers are available.
+     * \return Return the number of tx streamers (direction=="TX"), the number of rx
+     *         streamers (direction=="RX") or the total number of streamers.
+     */
+    size_t max_chan_count(const std::string& direction = "");
+
+    //! Coercer, attached to the "rate/value" property on the rx dsps.
+    double coerce_rx_samp_rate(rx_dsp_core_3000::sptr, size_t, const double);
+    void update_rx_samp_rate(const size_t, const double);
+
+    //! Coercer, attached to the "rate/value" property on the tx dsps.
+    double coerce_tx_samp_rate(tx_dsp_core_3000::sptr, size_t, const double);
+    void update_tx_samp_rate(const size_t, const double);
+
+    /* microphase for e310 */
+    struct tx_fc_cache_t
+    {
+        tx_fc_cache_t()
+                : stream_channel(0)
+                , device_channel(0)
+                , last_seq_out(0)
+                , last_seq_ack(0)
+                , seq_queue(1)
+        {
+        }
+        size_t stream_channel;
+        size_t device_channel;
+        size_t last_seq_out;
+        size_t last_seq_ack;
+        uhd::transport::bounded_buffer<size_t> seq_queue;
+        std::shared_ptr<async_md_type> async_queue;
+        std::shared_ptr<async_md_type> old_async_queue;
+    };
+
+    //rx connect
+    void _program_dispatcher(uhd::transport::zero_copy_if& xport);
+
+    static size_t _get_tx_flow_control_window(size_t payload_size,size_t hw_buff_size);
+    typedef boost::function<double(void)> tick_rate_retriever_t;
+
+    static void _handle_tx_async_msgs(boost::shared_ptr<tx_fc_cache_t> fc_cache,
+                                      uhd::transport::zero_copy_if::sptr xport,
+                                      tick_rate_retriever_t get_tick_rate);
+
+    static uhd::transport::managed_send_buffer::sptr _get_tx_buff_with_flowctrl(
+            uhd::task::sptr /*holds ref*/,
+            boost::shared_ptr<tx_fc_cache_t> fc_cache,
+            uhd::transport::zero_copy_if::sptr xport,
+            size_t fc_pkt_window,
+            const double timeout);
+};
+
+#endif /* INCLUDED_ANT_IMPL_HPP */
diff --git a/host/lib/usrp/ant/ant_io_impl.cpp b/host/lib/usrp/ant/ant_io_impl.cpp
new file mode 100644
index 000000000..de0fc39f6
--- /dev/null
+++ b/host/lib/usrp/ant/ant_io_impl.cpp
@@ -0,0 +1,719 @@
+//
+// Copyright 2012-2015 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#include "../../transport/super_recv_packet_handler.hpp"
+#include "../../transport/super_send_packet_handler.hpp"
+#include "ant_impl.hpp"
+#include "ant_regs.hpp"
+#include "uhd/utils/math.hpp"
+#include "uhdlib/usrp/common/async_packet_handler.hpp"
+#include "uhdlib/usrp/common/validate_subdev_spec.hpp"
+#include <functional>
+#include <memory>
+#include <set>
+
+using namespace uhd;
+using namespace uhd::usrp;
+using namespace uhd::transport;
+
+/***********************************************************************
+ * update streamer rates
+ **********************************************************************/
+void ant_impl::check_tick_rate_with_current_streamers(double rate)
+{
+    // Defined in ant_impl.cpp
+    enforce_tick_rate_limits(max_chan_count("RX"), rate, "RX");
+    enforce_tick_rate_limits(max_chan_count("TX"), rate, "TX");
+}
+
+// direction can either be "TX", "RX", or empty (default)
+size_t ant_impl::max_chan_count(const std::string& direction /* = "" */)
+{
+    size_t max_count = 0;
+    for (radio_perifs_t& perif : _radio_perifs) {
+        if ((direction == "RX" or direction.empty())
+            and not perif.rx_streamer.expired()) {
+            std::shared_ptr<sph::recv_packet_streamer> rx_streamer =
+                    std::dynamic_pointer_cast<sph::recv_packet_streamer>(
+                            perif.rx_streamer.lock());
+            max_count = std::max(max_count, rx_streamer->get_num_channels());
+        }
+        if ((direction == "TX" or direction.empty())
+            and not perif.tx_streamer.expired()) {
+            std::shared_ptr<sph::send_packet_streamer> tx_streamer =
+                    std::dynamic_pointer_cast<sph::send_packet_streamer>(
+                            perif.tx_streamer.lock());
+            max_count = std::max(max_count, tx_streamer->get_num_channels());
+        }
+    }
+    return max_count;
+}
+
+void ant_impl::check_streamer_args(const uhd::stream_args_t& args,
+                                   double tick_rate,
+                                   const std::string& direction /*= ""*/)
+{
+    std::set<size_t> chans_set;
+    for (size_t stream_i = 0; stream_i < args.channels.size(); stream_i++) {
+        const size_t chan = args.channels[stream_i];
+        chans_set.insert(chan);
+    }
+
+    enforce_tick_rate_limits(
+            chans_set.size(), tick_rate, direction); // Defined in ant_impl.cpp
+}
+
+void ant_impl::set_auto_tick_rate(
+        const double rate, const fs_path& tree_dsp_path, size_t num_chans)
+{
+    if (num_chans == 0) { // Divine them
+        num_chans = std::max(size_t(1), max_chan_count());
+    }
+    const double max_tick_rate = ad9361_device_t::AD9361_MAX_CLOCK_RATE / num_chans;
+    using namespace uhd::math;
+    if (rate != 0.0
+        and (fp_compare::fp_compare_delta<double>(rate, FREQ_COMPARISON_DELTA_HZ)
+             > max_tick_rate)) {
+        throw uhd::value_error(str(boost::format("Requested sampling rate (%.2f Msps) "
+                                                 "exceeds maximum tick rate of %.2f MHz.")
+                                   % (rate / 1e6) % (max_tick_rate / 1e6)));
+    }
+
+    // See also the doxygen documentation for these steps in ant_impl.hpp
+    // Step 1: Obtain LCM and max rate from all relevant dsps
+    uint32_t lcm_rate = (rate == 0) ? 1 : static_cast<uint32_t>(floor(rate + 0.5));
+    for (int i = 0; i < 2; i++) { // Loop through rx and tx
+        std::string dir = (i == 0) ? "tx" : "rx";
+        // We assume all 'set' DSPs are being used.
+        for (const std::string& dsp_no :
+                _tree->list(str(boost::format("/mboards/0/%s_dsps") % dir))) {
+            fs_path dsp_path = str(boost::format("/mboards/0/%s_dsps/%s") % dir % dsp_no);
+            if (dsp_path == tree_dsp_path) {
+                continue;
+            }
+            if (not _tree->access<bool>(dsp_path / "rate/set").get()) {
+                continue;
+            }
+            double this_dsp_rate = _tree->access<double>(dsp_path / "rate/value").get();
+            // Check if the user selected something completely unreasonable:
+            if (fp_compare::fp_compare_delta<double>(
+                    this_dsp_rate, FREQ_COMPARISON_DELTA_HZ)
+                > max_tick_rate) {
+                throw uhd::value_error(
+                        str(boost::format("Requested sampling rate (%.2f Msps) exceeds "
+                                          "maximum tick rate of %.2f MHz.")
+                            % (this_dsp_rate / 1e6) % (max_tick_rate / 1e6)));
+            }
+            // Clean up floating point rounding errors if they crept in
+            this_dsp_rate = std::min(max_tick_rate, this_dsp_rate);
+            lcm_rate      = uhd::math::lcm<uint32_t>(
+                    lcm_rate, static_cast<uint32_t>(floor(this_dsp_rate + 0.5)));
+        }
+    }
+    if (lcm_rate == 1) {
+        // In this case, no one has ever set a sampling rate.
+        return;
+    }
+
+    double base_rate = static_cast<double>(lcm_rate);
+    try {
+        // Step 2: Get a good tick rate value
+        const double new_rate = _codec_mgr->get_auto_tick_rate(base_rate, num_chans);
+        // Step 3: Set the new tick rate value (if any change)
+        if (!uhd::math::frequencies_are_equal(
+                _tree->access<double>("/mboards/0/tick_rate").get(), new_rate)) {
+            _tree->access<double>("/mboards/0/tick_rate").set(new_rate);
+        }
+    } catch (const uhd::value_error&) {
+        UHD_LOGGER_WARNING("ANT") << "Cannot automatically determine an appropriate "
+                                     "tick rate for these sampling rates."
+                                  << "Consider using different sampling rates, or "
+                                     "manually specify a suitable master clock rate.";
+        return; // Let the others handle this
+    }
+}
+
+void ant_impl::update_tick_rate(const double new_tick_rate)
+{
+    check_tick_rate_with_current_streamers(new_tick_rate);
+
+    for (radio_perifs_t& perif : _radio_perifs) {
+        std::shared_ptr<sph::recv_packet_streamer> my_streamer =
+                std::dynamic_pointer_cast<sph::recv_packet_streamer>(
+                        perif.rx_streamer.lock());
+        if (my_streamer)
+            my_streamer->set_tick_rate(new_tick_rate);
+        perif.framer->set_tick_rate(new_tick_rate);
+    }
+    for (radio_perifs_t& perif : _radio_perifs) {
+        std::shared_ptr<sph::send_packet_streamer> my_streamer =
+                std::dynamic_pointer_cast<sph::send_packet_streamer>(
+                        perif.tx_streamer.lock());
+        if (my_streamer)
+            my_streamer->set_tick_rate(new_tick_rate);
+    }
+}
+
+void ant_impl::update_rx_dsp_tick_rate(
+        const double tick_rate, rx_dsp_core_3000::sptr ddc, uhd::fs_path rx_dsp_path)
+{
+    ddc->set_tick_rate(tick_rate);
+    if (_tree->access<bool>(rx_dsp_path / "rate" / "set").get()) {
+        ddc->set_host_rate(_tree->access<double>(rx_dsp_path / "rate" / "value").get());
+    }
+}
+
+void ant_impl::update_tx_dsp_tick_rate(
+        const double tick_rate, tx_dsp_core_3000::sptr duc, uhd::fs_path tx_dsp_path)
+{
+    duc->set_tick_rate(tick_rate);
+    if (_tree->access<bool>(tx_dsp_path / "rate" / "set").get()) {
+        duc->set_host_rate(_tree->access<double>(tx_dsp_path / "rate" / "value").get());
+    }
+}
+
+#define CHECK_RATE_AND_THROW(rate)                                                    \
+    if (uhd::math::fp_compare::fp_compare_delta<double>(                              \
+            rate, uhd::math::FREQ_COMPARISON_DELTA_HZ)                                \
+        > uhd::math::fp_compare::fp_compare_delta<double>(                            \
+              ad9361_device_t::AD9361_MAX_CLOCK_RATE,                                 \
+              uhd::math::FREQ_COMPARISON_DELTA_HZ)) {                                 \
+        throw uhd::value_error(                                                       \
+            str(boost::format(                                                        \
+                    "Requested sampling rate (%.2f Msps) exceeds maximum tick rate.") \
+                % (rate / 1e6)));                                                     \
+    }
+
+double ant_impl::coerce_rx_samp_rate(
+        rx_dsp_core_3000::sptr ddc, size_t dspno, const double rx_rate)
+{
+    // Have to set tick rate first, or the ddc will change the requested rate based on
+    // default tick rate
+    if (_tree->access<bool>("/mboards/0/auto_tick_rate").get()) {
+        CHECK_RATE_AND_THROW(rx_rate);
+        const std::string dsp_path =
+                (boost::format("/mboards/0/rx_dsps/%s") % dspno).str();
+        set_auto_tick_rate(rx_rate, dsp_path);
+    }
+    return ddc->set_host_rate(rx_rate);
+}
+
+void ant_impl::update_rx_samp_rate(const size_t dspno, const double rate)
+{
+    std::shared_ptr<sph::recv_packet_streamer> my_streamer =
+            std::dynamic_pointer_cast<sph::recv_packet_streamer>(
+                    _radio_perifs[dspno].rx_streamer.lock());
+    if (not my_streamer)
+        return;
+    my_streamer->set_samp_rate(rate);
+    const double adj = _radio_perifs[dspno].ddc->get_scaling_adjustment();
+    my_streamer->set_scale_factor(adj);
+    _codec_mgr->check_bandwidth(rate, "Rx");
+}
+
+double ant_impl::coerce_tx_samp_rate(
+        tx_dsp_core_3000::sptr duc, size_t dspno, const double tx_rate)
+{
+    // Have to set tick rate first, or the duc will change the requested rate based on
+    // default tick rate
+    if (_tree->access<bool>("/mboards/0/auto_tick_rate").get()) {
+        CHECK_RATE_AND_THROW(tx_rate);
+        const std::string dsp_path =
+                (boost::format("/mboards/0/tx_dsps/%s") % dspno).str();
+        set_auto_tick_rate(tx_rate, dsp_path);
+    }
+    return duc->set_host_rate(tx_rate);
+}
+
+void ant_impl::update_tx_samp_rate(const size_t dspno, const double rate)
+{
+    std::shared_ptr<sph::send_packet_streamer> my_streamer =
+            std::dynamic_pointer_cast<sph::send_packet_streamer>(
+                    _radio_perifs[dspno].tx_streamer.lock());
+    if (not my_streamer)
+        return;
+    my_streamer->set_samp_rate(rate);
+    const double adj = _radio_perifs[dspno].duc->get_scaling_adjustment();
+    my_streamer->set_scale_factor(adj);
+    _codec_mgr->check_bandwidth(rate, "Tx");
+}
+
+/***********************************************************************
+ * frontend selection
+ **********************************************************************/
+uhd::usrp::subdev_spec_t ant_impl::coerce_subdev_spec(
+        const uhd::usrp::subdev_spec_t& spec_)
+{
+    uhd::usrp::subdev_spec_t spec = spec_;
+    // Because of the confusing nature of the subdevs on ANT
+    // with different revs, we provide a convenience override,
+    // where both A:A and A:B are mapped to A:A.
+    //
+    // Any other spec is probably illegal and will be caught by
+    // validate_subdev_spec().
+    if (!spec.empty()
+        and (_product == B200 or _product == B200MINI or _product == B205MINI)
+        and spec[0].sd_name == "B") {
+        spec[0].sd_name = "A";
+    }
+    return spec;
+}
+
+void ant_impl::update_subdev_spec(
+        const std::string& tx_rx, const uhd::usrp::subdev_spec_t& spec)
+{
+    // sanity checking
+    if (!spec.empty()) {
+        validate_subdev_spec(_tree, spec, tx_rx);
+    }
+
+    std::vector<size_t> chan_to_dsp_map(spec.size(), 0);
+    for (size_t i = 0; i < spec.size(); i++) {
+        chan_to_dsp_map[i] = (spec[i].sd_name == "A") ? 0 : 1;
+    }
+    _tree->access<std::vector<size_t>>("/mboards/0" / (tx_rx + "_chan_dsp_mapping"))
+            .set(chan_to_dsp_map);
+
+    this->update_enables();
+}
+
+static void b200_if_hdr_unpack_le(
+        const uint32_t* packet_buff, vrt::if_packet_info_t& if_packet_info)
+{
+    if_packet_info.link_type = vrt::if_packet_info_t::LINK_TYPE_CHDR;
+    return vrt::if_hdr_unpack_le(packet_buff, if_packet_info);
+}
+
+static void b200_if_hdr_pack_le(
+        uint32_t* packet_buff, vrt::if_packet_info_t& if_packet_info)
+{
+    if_packet_info.link_type = vrt::if_packet_info_t::LINK_TYPE_CHDR;
+    return vrt::if_hdr_pack_le(packet_buff, if_packet_info);
+}
+
+/***********************************************************************
+ * Async Data
+ **********************************************************************/
+bool ant_impl::recv_async_msg(async_metadata_t& async_metadata, double timeout)
+{
+    return _async_task_data->async_md->pop_with_timed_wait(async_metadata, timeout);
+}
+
+/*
+ * This method is constantly called in a msg_task loop.
+ * Incoming messages are dispatched in to the hosts radio_ctrl_cores.
+ * The radio_ctrl_core queues are accessed via a weak_ptr to them, stored in
+ * AsyncTaskData. During shutdown the radio_ctrl_core dtor's are called. An empty
+ * peek32(0) is sent out to flush pending async messages. The response to those messages
+ * can't be delivered to the ctrl_core queues anymore because the shared pointer
+ * corresponding to the weak_ptrs is no longer valid. Those stranded messages are put into
+ * a dump_queue implemented in msg_task. A radio_ctrl_core can search for missing messages
+ * there.
+ */
+boost::optional<uhd::msg_task::msg_type_t> ant_impl::handle_async_task(
+        uhd::transport::zero_copy_if::sptr xport, std::shared_ptr<AsyncTaskData> data)
+{
+    managed_recv_buffer::sptr buff = xport->get_recv_buff();
+    if (not buff or buff->size() < 8)
+        return boost::none;
+
+    const uint32_t sid = uhd::wtohx(buff->cast<const uint32_t*>()[1]);
+    switch (sid) {
+        // if the packet is a control response
+        case ANT_RESP0_MSG_SID:
+        case ANT_RESP1_MSG_SID:
+        case ANT_LOCAL_RESP_SID: {
+            ant_radio_ctrl_core::sptr ctrl;
+            if (sid == ANT_RESP0_MSG_SID)
+                ctrl = data->radio_ctrl[0].lock();
+            if (sid == ANT_RESP1_MSG_SID)
+                ctrl = data->radio_ctrl[1].lock();
+            if (sid == ANT_LOCAL_RESP_SID)
+                ctrl = data->local_ctrl.lock();
+            if (ctrl) {
+                ctrl->push_response(buff->cast<const uint32_t*>());
+            } else {
+                return std::make_pair(sid,
+                                      uhd::msg_task::buff_to_vector(buff->cast<uint8_t*>(), buff->size()));
+            }
+            break;
+        }
+
+            // if the packet is a uart message
+        case ANT_RX_GPS_UART_SID: {
+            data->gpsdo_uart->handle_uart_packet(buff);
+            break;
+        }
+
+            // or maybe the packet is a TX async message
+        case ANT_TX_MSG0_SID:
+        case ANT_TX_MSG1_SID: {
+            const size_t i = (sid == ANT_TX_MSG0_SID) ? 0 : 1;
+
+            // extract packet info
+            vrt::if_packet_info_t if_packet_info;
+            if_packet_info.num_packet_words32 = buff->size() / sizeof(uint32_t);
+            const uint32_t* packet_buff       = buff->cast<const uint32_t*>();
+
+            // unpacking can fail
+            try {
+                b200_if_hdr_unpack_le(packet_buff, if_packet_info);
+            } catch (const std::exception& ex) {
+                UHD_LOGGER_ERROR("ANT") << "Error parsing ctrl packet: " << ex.what();
+                break;
+            }
+
+            // fill in the async metadata
+            async_metadata_t metadata;
+            load_metadata_from_buff(uhd::wtohx<uint32_t>,
+                                    metadata,
+                                    if_packet_info,
+                                    packet_buff,
+                                    _tick_rate,
+                                    i);
+            data->async_md->push_with_pop_on_full(metadata);
+            standard_async_msg_prints(metadata);
+            break;
+        }
+
+            // doh!
+        default:
+            UHD_LOGGER_ERROR("ANT") << "Got a ctrl packet with unknown SID " << sid;
+    }
+    return boost::none;
+}
+
+/***********************************************************************
+ * Receive streamer
+ **********************************************************************/
+rx_streamer::sptr ant_impl::get_rx_stream(const uhd::stream_args_t& args_)
+{
+    std::lock_guard<std::mutex> lock(_transport_setup_mutex);
+
+    stream_args_t args = args_;
+
+    // setup defaults for unspecified values
+    if (args.otw_format.empty())
+        args.otw_format = "sc16";
+    args.channels = args.channels.empty() ? std::vector<size_t>(1, 0) : args.channels;
+
+    if (_tree->access<bool>("/mboards/0/auto_tick_rate").get()) {
+        set_auto_tick_rate(0, "", args.channels.size());
+    }
+    check_streamer_args(args, this->get_tick_rate(), "RX");
+
+    std::shared_ptr<sph::recv_packet_streamer> my_streamer;
+    for (size_t stream_i = 0; stream_i < args.channels.size(); stream_i++) {
+        const size_t radio_index =
+                _tree->access<std::vector<size_t>>("/mboards/0/rx_chan_dsp_mapping")
+                        .get()
+                        .at(args.channels[stream_i]);
+        radio_perifs_t& perif = _radio_perifs[radio_index];
+        if (args.otw_format == "sc16")
+            perif.ctrl->poke32(TOREG(SR_RX_FMT), 0);
+        if (args.otw_format == "sc12")
+            perif.ctrl->poke32(TOREG(SR_RX_FMT), 1);
+        if (args.otw_format == "fc32")
+            perif.ctrl->poke32(TOREG(SR_RX_FMT), 2);
+        if (args.otw_format == "sc8")
+            perif.ctrl->poke32(TOREG(SR_RX_FMT), 3);
+        const uint32_t sid = radio_index ? ANT_RX_DATA1_SID : ANT_RX_DATA0_SID;
+
+        // calculate packet size
+        static const size_t hdr_size =
+                0
+                + vrt::max_if_hdr_words32 * sizeof(uint32_t)
+                //+ sizeof(vrt::if_packet_info_t().tlr) //no longer using trailer
+                - sizeof(vrt::if_packet_info_t().cid) // no class id ever used
+                - sizeof(vrt::if_packet_info_t().tsi) // no int time ever used
+        ;
+        const size_t bpp = _data_rx_transport->get_recv_frame_size() - hdr_size;
+        const size_t bpi = convert::get_bytes_per_item(args.otw_format);
+        size_t spp       = unsigned(args.args.cast<double>("spp", bpp / bpi));
+        spp = std::min<size_t>(4092, spp); // FPGA FIFO maximum for framing at full rate
+
+        // make the new streamer given the samples per packet
+        if (not my_streamer)
+            my_streamer = std::make_shared<sph::recv_packet_streamer>(spp);
+        my_streamer->resize(args.channels.size());
+
+        // init some streamer stuff
+        my_streamer->set_vrt_unpacker(&b200_if_hdr_unpack_le);
+
+        // set the converter
+        uhd::convert::id_type id;
+        id.input_format  = args.otw_format + "_item32_le";
+        id.num_inputs    = 1;
+        id.output_format = args.cpu_format;
+        id.num_outputs   = 1;
+        my_streamer->set_converter(id);
+
+        perif.framer->clear();
+        perif.framer->set_nsamps_per_packet(spp);
+        perif.framer->set_sid(sid);
+        perif.framer->setup(args);
+        perif.ddc->setup(args);
+        _demux->realloc_sid(sid);
+        my_streamer->set_xport_chan_get_buff(stream_i,
+                                             std::bind(&recv_packet_demuxer_3000::get_recv_buff,
+                                                       _demux,
+                                                       sid,
+                                                       std::placeholders::_1),
+                                             true /*flush*/);
+        my_streamer->set_overflow_handler(
+                stream_i, std::bind(&ant_impl::handle_overflow, this, radio_index));
+        my_streamer->set_issue_stream_cmd(stream_i,
+                                          std::bind(&rx_vita_core_3000::issue_stream_command,
+                                                    perif.framer,
+                                                    std::placeholders::_1));
+        perif.rx_streamer = my_streamer; // store weak pointer
+
+        // sets all tick and samp rates on this streamer
+        this->update_tick_rate(this->get_tick_rate());
+        _tree
+                ->access<double>(
+                        str(boost::format("/mboards/0/rx_dsps/%u/rate/value") % radio_index))
+                .update();
+    }
+    this->update_enables();
+
+    return my_streamer;
+}
+
+void ant_impl::handle_overflow(const size_t radio_index)
+{
+    std::shared_ptr<sph::recv_packet_streamer> my_streamer =
+            std::dynamic_pointer_cast<sph::recv_packet_streamer>(
+                    _radio_perifs[radio_index].rx_streamer.lock());
+    if (my_streamer->get_num_channels() == 2) // MIMO time
+    {
+        // find out if we were in continuous mode before stopping
+        const bool in_continuous_streaming_mode =
+                _radio_perifs[radio_index].framer->in_continuous_streaming_mode();
+        // stop streaming
+        my_streamer->issue_stream_cmd(stream_cmd_t::STREAM_MODE_STOP_CONTINUOUS);
+        // flush demux
+        _demux->realloc_sid(ANT_RX_DATA0_SID);
+        _demux->realloc_sid(ANT_RX_DATA1_SID);
+        // flush actual transport
+        while (_data_rx_transport->get_recv_buff(0.001)) {
+
+        }
+        // restart streaming
+        if (in_continuous_streaming_mode) {
+            stream_cmd_t stream_cmd(stream_cmd_t::STREAM_MODE_START_CONTINUOUS);
+            stream_cmd.stream_now = false;
+            stream_cmd.time_spec =
+                    _radio_perifs[radio_index].time64->get_time_now() + time_spec_t(0.01);
+            // FIXME: temporarily remove the start stream command.
+            // This will avoid an issue that gets the b210 in a bad state.
+            // my_streamer->issue_stream_cmd(stream_cmd);
+        }
+    } else {
+        while (_data_rx_transport->get_recv_buff(0.001)) {
+        }
+        // FIXME: temporarily remove the overflow handling that re-issues a stream
+        //        command. This will avoid an issue that gets the b210 in a bad state.
+//         _radio_perifs[radio_index].framer->handle_overflow();
+    }
+}
+
+/***********************************************************************
+ * Transmit streamer
+ **********************************************************************/
+tx_streamer::sptr ant_impl::get_tx_stream(const uhd::stream_args_t& args_)
+{
+    std::lock_guard<std::mutex> lock(_transport_setup_mutex);
+
+    stream_args_t args = args_;
+
+    // setup defaults for unspecified values
+    if (args.otw_format.empty())
+        args.otw_format = "sc16";
+    args.channels = args.channels.empty() ? std::vector<size_t>(1, 0) : args.channels;
+
+    if (_tree->access<bool>("/mboards/0/auto_tick_rate").get()) {
+        set_auto_tick_rate(0, "", args.channels.size());
+    }
+    check_streamer_args(args, this->get_tick_rate(), "TX");
+
+    std::shared_ptr<sph::send_packet_streamer> my_streamer;
+    for (size_t stream_i = 0; stream_i < args.channels.size(); stream_i++) {
+        /* microphase */
+        const size_t chan = args.channels[stream_i];
+
+        const size_t radio_index =
+                _tree->access<std::vector<size_t>>("/mboards/0/tx_chan_dsp_mapping")
+                        .get()
+                        .at(args.channels[stream_i]);
+        radio_perifs_t& perif = _radio_perifs[radio_index];
+        if (args.otw_format == "sc16")
+            perif.ctrl->poke32(TOREG(SR_TX_FMT), 0);
+        if (args.otw_format == "sc12")
+            perif.ctrl->poke32(TOREG(SR_TX_FMT), 1);
+        if (args.otw_format == "fc32")
+            perif.ctrl->poke32(TOREG(SR_TX_FMT), 2);
+        if (args.otw_format == "sc8")
+            perif.ctrl->poke32(TOREG(SR_TX_FMT), 3);
+
+        // calculate packet size
+        static const size_t hdr_size =
+                0
+                + vrt::max_if_hdr_words32 * sizeof(uint32_t)
+                //+ sizeof(vrt::if_packet_info_t().tlr) //forced to have trailer
+                - sizeof(vrt::if_packet_info_t().cid) // no class id ever used
+                - sizeof(vrt::if_packet_info_t().tsi) // no int time ever used
+        ;
+        static size_t bpp = _data_tx_transport->get_send_frame_size() - hdr_size;
+        const size_t spp        = bpp / convert::get_bytes_per_item(args.otw_format);
+
+
+        // make the new streamer given the samples per packet
+        if (not my_streamer)
+            my_streamer = std::make_shared<sph::send_packet_streamer>(spp);
+        my_streamer->resize(args.channels.size());
+
+        // init some streamer stuff
+        my_streamer->set_vrt_packer(&b200_if_hdr_pack_le);
+
+        // set the converter
+        uhd::convert::id_type id;
+        id.input_format  = args.cpu_format;
+        id.num_inputs    = 1;
+        id.output_format = args.otw_format + "_item32_le";
+        id.num_outputs   = 1;
+        my_streamer->set_converter(id);
+
+        perif.deframer->clear();
+        perif.deframer->setup(args);
+        perif.duc->setup(args);
+        if(_product_mp == E310) {
+            // flow control setup
+            size_t fc_window = _get_tx_flow_control_window(bpp, BUFF_SIZE);
+            // In packets
+            perif.deframer->configure_flow_control(0/* cycs off */, 30);
+            boost::shared_ptr<tx_fc_cache_t> fc_cache(new tx_fc_cache_t());
+            fc_cache->stream_channel = stream_i;
+            fc_cache->device_channel = chan;
+            fc_cache->async_queue = _async_task_data->async_md;
+            fc_cache->old_async_queue = _async_task_data->async_md;
+
+            tick_rate_retriever_t get_tick_rate_fn =
+                    boost::bind(&ant_impl::get_tick_rate, this);
+
+            if(chan == 0){
+                task::sptr task =
+                        task::make(boost::bind(&ant_impl::_handle_tx_async_msgs,
+                                               fc_cache,
+                                               _data_tx_transport,
+                                               get_tick_rate_fn));
+
+                my_streamer->set_xport_chan_get_buff(stream_i,
+                                                     boost::bind(&ant_impl::_get_tx_buff_with_flowctrl,
+                                                                 task,
+                                                                 fc_cache,
+                                                                 _data_tx_transport,
+                                                                 fc_window,
+                                                                 boost::placeholders::_1));
+            }
+            else if(chan == 1){
+                task::sptr task =
+                        task::make(boost::bind(&ant_impl::_handle_tx_async_msgs,
+                                               fc_cache,
+                                               _data_tx1_transport,
+                                               get_tick_rate_fn));
+
+                my_streamer->set_xport_chan_get_buff(stream_i,
+                                                     boost::bind(&ant_impl::_get_tx_buff_with_flowctrl,
+                                                                 task,
+                                                                 fc_cache,
+                                                                 _data_tx1_transport,
+                                                                 fc_window,
+                                                                 boost::placeholders::_1));
+            }
+
+        }
+
+
+        my_streamer->set_async_receiver(boost::bind(
+                &async_md_type::pop_with_timed_wait, _async_task_data->async_md, boost::placeholders::_1, boost::placeholders::_2));
+        my_streamer->set_xport_chan_sid(
+                stream_i, true, radio_index ? ANT_TX_DATA1_SID : ANT_TX_DATA0_SID);
+        my_streamer->set_enable_trailer(false); // TODO not implemented trailer support
+        // yet
+        perif.tx_streamer = my_streamer; // store weak pointer
+        // sets all tick and samp rates on this streamer
+        this->update_tick_rate(this->get_tick_rate());
+        _tree
+                ->access<double>(
+                        str(boost::format("/mboards/0/tx_dsps/%u/rate/value") % radio_index))
+                .update();
+    }
+    this->update_enables();
+
+    return my_streamer;
+}
+
+/* Microphase for ant */
+size_t ant_impl::_get_tx_flow_control_window(size_t payload_size, size_t hw_buff_size) {
+    size_t window_in_pkts = hw_buff_size / payload_size;
+    if (window_in_pkts == 0) {
+        throw uhd::value_error("send_buff_size must be larger than the send_frame_size.");
+    }
+    return window_in_pkts;
+}
+
+void ant_impl::_handle_tx_async_msgs(boost::shared_ptr<tx_fc_cache_t> fc_cache,
+                                     uhd::transport::zero_copy_if::sptr xport, tick_rate_retriever_t get_tick_rate) {
+    managed_recv_buffer::sptr buff = xport->get_recv_buff();
+    if(not buff)
+        return;
+    vrt::if_packet_info_t if_packet_info;
+    if_packet_info.num_packet_words32 = buff->size() / sizeof(uint32_t);
+    const uint32_t* packet_buff       = buff->cast<const uint32_t*>();
+
+    // unpacking can fail
+    uint32_t (*endian_conv)(uint32_t) = uhd::wtohx;
+    try {
+        b200_if_hdr_unpack_le(packet_buff, if_packet_info);
+    } catch (const std::exception& ex) {
+        UHD_LOGGER_ERROR("ANT") << "Error parsing ctrl packet: " << ex.what();
+    }
+    async_metadata_t metadata;
+    load_metadata_from_buff(endian_conv,
+                            metadata,
+                            if_packet_info,
+                            packet_buff,
+                            get_tick_rate(),
+                            fc_cache->stream_channel);
+
+    const size_t seq = metadata.user_payload[0];
+    fc_cache->seq_queue.push_with_pop_on_full(seq);
+    standard_async_msg_prints(metadata);
+}
+
+uhd::transport::managed_send_buffer::sptr ant_impl::_get_tx_buff_with_flowctrl(uhd::task::sptr,
+                                                                               boost::shared_ptr<tx_fc_cache_t> fc_cache,
+                                                                               uhd::transport::zero_copy_if::sptr xport,
+                                                                               size_t fc_pkt_window,
+                                                                               const double timeout) {
+    while (true) {
+        const size_t delta = (fc_cache->last_seq_out & 0xFFF)
+                             - (fc_cache->last_seq_ack & 0xFFF);
+        if ((delta & 0xFFF) <= fc_pkt_window)
+            break;
+        const bool ok =
+                fc_cache->seq_queue.pop_with_timed_wait(fc_cache->last_seq_ack, timeout);
+        if (not ok)
+            return uhd::transport::managed_send_buffer::sptr(); // timeout waiting for flow control
+    }
+
+    managed_send_buffer::sptr buff = xport->get_send_buff(timeout);
+    if (buff)
+        fc_cache->last_seq_out++; // update seq, this will actually be a send
+    return buff;
+}
\ No newline at end of file
diff --git a/host/lib/usrp/ant/ant_radio_ctrl_core.cpp b/host/lib/usrp/ant/ant_radio_ctrl_core.cpp
new file mode 100644
index 000000000..0bc568168
--- /dev/null
+++ b/host/lib/usrp/ant/ant_radio_ctrl_core.cpp
@@ -0,0 +1,348 @@
+//
+// Copyright 2012-2015 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#include "ant_radio_ctrl_core.hpp"
+#include <uhd/exception.hpp>
+#include <uhd/transport/bounded_buffer.hpp>
+#include <uhd/transport/vrt_if_packet.hpp>
+#include <uhd/utils/byteswap.hpp>
+#include <uhd/utils/log.hpp>
+#include <uhd/utils/safe_call.hpp>
+#include <uhdlib/usrp/common/async_packet_handler.hpp>
+#include <boost/format.hpp>
+#include <functional>
+#include <mutex>
+#include <queue>
+
+using namespace uhd;
+using namespace uhd::usrp;
+using namespace uhd::transport;
+
+static const double ACK_TIMEOUT     = 2.0; // supposed to be worst case practical timeout
+static const double MASSIVE_TIMEOUT = 10.0; // for when we wait on a timed command
+static const size_t SR_READBACK     = 32;
+
+ant_radio_ctrl_core::~ant_radio_ctrl_core(void)
+{
+    /* NOP */
+}
+
+class ant_radio_ctrl_core_impl : public ant_radio_ctrl_core
+{
+public:
+    ant_radio_ctrl_core_impl(const bool big_endian,
+        uhd::transport::zero_copy_if::sptr ctrl_xport,
+        uhd::transport::zero_copy_if::sptr resp_xport,
+        const uint32_t sid,
+        const std::string& name)
+        : _link_type(vrt::if_packet_info_t::LINK_TYPE_CHDR)
+        , _packet_type(vrt::if_packet_info_t::PACKET_TYPE_CONTEXT)
+        , _bige(big_endian)
+        , _ctrl_xport(ctrl_xport)
+        , _resp_xport(resp_xport)
+        , _sid(sid)
+        , _name(name)
+        , _seq_out(0)
+        , _timeout(ACK_TIMEOUT)
+        , _resp_queue(128 /*max response msgs*/)
+        , _resp_queue_size(_resp_xport ? _resp_xport->get_num_recv_frames() : 3)
+    {
+        if (resp_xport) {
+            while (resp_xport->get_recv_buff(0.0)) {
+            } // flush
+        }
+        this->set_time(uhd::time_spec_t(0.0));
+        this->set_tick_rate(1.0); // something possible but bogus
+    }
+
+    ~ant_radio_ctrl_core_impl(void) override
+    {
+        _timeout = ACK_TIMEOUT; // reset timeout to something small
+        UHD_SAFE_CALL(
+            this->peek32(0); // dummy peek with the purpose of ack'ing all packets
+            _async_task.reset(); // now its ok to release the task
+        )
+    }
+
+    /*******************************************************************
+     * Peek and poke 32 bit implementation
+     ******************************************************************/
+    void poke32(const wb_addr_type addr, const uint32_t data) override
+    {
+        std::lock_guard<std::mutex> lock(_mutex);
+        this->send_pkt(addr / 4, data);
+        this->wait_for_ack(false);
+    }
+
+    uint32_t peek32(const wb_addr_type addr) override
+    {
+        std::lock_guard<std::mutex> lock(_mutex);
+        this->send_pkt(SR_READBACK, addr / 8);
+        const uint64_t res = this->wait_for_ack(true);
+        const uint32_t lo  = uint32_t(res & 0xffffffff);
+        const uint32_t hi  = uint32_t(res >> 32);
+        return ((addr / 4) & 0x1) ? hi : lo;
+    }
+
+    uint64_t peek64(const wb_addr_type addr) override
+    {
+        std::lock_guard<std::mutex> lock(_mutex);
+        this->send_pkt(SR_READBACK, addr / 8);
+        return this->wait_for_ack(true);
+    }
+
+    /*******************************************************************
+     * Update methods for time
+     ******************************************************************/
+    void set_time(const uhd::time_spec_t& time) override
+    {
+        std::lock_guard<std::mutex> lock(_mutex);
+        _time     = time;
+        _use_time = _time != uhd::time_spec_t(0.0);
+        if (_use_time)
+            _timeout = MASSIVE_TIMEOUT; // permanently sets larger timeout
+    }
+
+    uhd::time_spec_t get_time(void) override
+    {
+        std::lock_guard<std::mutex> lock(_mutex);
+        return _time;
+    }
+
+    void set_tick_rate(const double rate) override
+    {
+        std::lock_guard<std::mutex> lock(_mutex);
+        _tick_rate = rate;
+    }
+
+private:
+    // This is the buffer type for messages in radio control core.
+    struct resp_buff_type
+    {
+        uint32_t data[8];
+    };
+
+    /*******************************************************************
+     * Primary control and interaction private methods
+     ******************************************************************/
+    UHD_INLINE void send_pkt(const uint32_t addr, const uint32_t data = 0)
+    {
+        managed_send_buffer::sptr buff = _ctrl_xport->get_send_buff(0.0);
+        if (not buff) {
+            throw uhd::runtime_error("fifo ctrl timed out getting a send buffer");
+        }
+        uint32_t* pkt = buff->cast<uint32_t*>();
+
+        // load packet info
+        vrt::if_packet_info_t packet_info;
+        packet_info.link_type           = _link_type;
+        packet_info.packet_type         = _packet_type;
+        packet_info.num_payload_words32 = 2;
+        packet_info.num_payload_bytes =
+            packet_info.num_payload_words32 * sizeof(uint32_t);
+        packet_info.packet_count = _seq_out;
+        packet_info.tsf          = _time.to_ticks(_tick_rate);
+        packet_info.sob          = false;
+        packet_info.eob          = false;
+        packet_info.sid          = _sid;
+        packet_info.has_sid      = true;
+        packet_info.has_cid      = false;
+        packet_info.has_tsi      = false;
+        packet_info.has_tsf      = _use_time;
+        packet_info.has_tlr      = false;
+
+        // load header
+        if (_bige)
+            vrt::if_hdr_pack_be(pkt, packet_info);
+        else
+            vrt::if_hdr_pack_le(pkt, packet_info);
+
+        // load payload
+        pkt[packet_info.num_header_words32 + 0] = (_bige) ? uhd::htonx(addr)
+                                                          : uhd::htowx(addr);
+        pkt[packet_info.num_header_words32 + 1] = (_bige) ? uhd::htonx(data)
+                                                          : uhd::htowx(data);
+        // UHD_LOGGER_INFO("radio_ctrl") << boost::format("0x%08x, 0x%08x\n") % addr %
+        // data; send the buffer over the interface
+        _outstanding_seqs.push(_seq_out);
+        buff->commit(sizeof(uint32_t) * (packet_info.num_packet_words32));
+
+        _seq_out++; // inc seq for next call
+    }
+
+    UHD_INLINE uint64_t wait_for_ack(const bool readback)
+    {
+        while (readback or (_outstanding_seqs.size() >= _resp_queue_size)) {
+            // get seq to ack from outstanding packets list
+            UHD_ASSERT_THROW(not _outstanding_seqs.empty());
+            const size_t seq_to_ack = _outstanding_seqs.front();
+            _outstanding_seqs.pop();
+
+            // parse the packet
+            vrt::if_packet_info_t packet_info;
+            resp_buff_type resp_buff;
+            memset(&resp_buff, 0x00, sizeof(resp_buff));
+            uint32_t const* pkt = NULL;
+            managed_recv_buffer::sptr buff;
+
+            // get buffer from response endpoint - or die in timeout
+            if (_resp_xport) {
+                buff = _resp_xport->get_recv_buff(_timeout);
+                try {
+                    UHD_ASSERT_THROW(bool(buff));
+                    UHD_ASSERT_THROW(buff->size() > 0);
+                } catch (const std::exception& ex) {
+                    throw uhd::io_error(
+                        str(boost::format("Radio ctrl (%s) no response packet - %s")
+                            % _name % ex.what()));
+                }
+                pkt                            = buff->cast<const uint32_t*>();
+                packet_info.num_packet_words32 = buff->size() / sizeof(uint32_t);
+            }
+
+            // get buffer from response endpoint - or die in timeout
+            else {
+                /*
+                 * Couldn't get message with haste.
+                 * Now check both possible queues for messages.
+                 * Messages should come in on _resp_queue,
+                 * but could end up in dump_queue.
+                 * If we don't get a message --> Die in timeout.
+                 */
+                double accum_timeout       = 0.0;
+                const double short_timeout = 0.005; // == 5ms
+                while (
+                    not((_resp_queue.pop_with_haste(resp_buff))
+                        || (check_dump_queue(resp_buff))
+                        || (_resp_queue.pop_with_timed_wait(resp_buff, short_timeout)))) {
+                    /*
+                     * If a message couldn't be received within a given timeout
+                     * --> throw AssertionError!
+                     */
+                    accum_timeout += short_timeout;
+                    UHD_ASSERT_THROW(accum_timeout < _timeout);
+                }
+
+                pkt                            = resp_buff.data;
+                packet_info.num_packet_words32 = sizeof(resp_buff) / sizeof(uint32_t);
+            }
+
+            // parse the buffer
+            try {
+                packet_info.link_type = _link_type;
+                if (_bige)
+                    vrt::if_hdr_unpack_be(pkt, packet_info);
+                else
+                    vrt::if_hdr_unpack_le(pkt, packet_info);
+            } catch (const std::exception& ex) {
+                UHD_LOGGER_ERROR("radio_ctrl")
+                    << "Radio ctrl bad VITA packet: " << ex.what();
+                if (buff) {
+                    UHD_VAR(buff->size());
+                } else {
+                    UHD_LOGGER_INFO("radio_ctrl") << "buff is NULL";
+                }
+                UHD_LOGGER_INFO("radio_ctrl") << std::hex << pkt[0] << std::dec;
+                UHD_LOGGER_INFO("radio_ctrl") << std::hex << pkt[1] << std::dec;
+                UHD_LOGGER_INFO("radio_ctrl") << std::hex << pkt[2] << std::dec;
+                UHD_LOGGER_INFO("radio_ctrl") << std::hex << pkt[3] << std::dec;
+            }
+
+            // check the buffer
+            try {
+                UHD_ASSERT_THROW(packet_info.has_sid);
+                UHD_ASSERT_THROW(
+                    packet_info.sid == uint32_t((_sid >> 16) | (_sid << 16)));
+                UHD_ASSERT_THROW(packet_info.packet_count == (seq_to_ack & 0xfff));
+                UHD_ASSERT_THROW(packet_info.num_payload_words32 == 2);
+                UHD_ASSERT_THROW(packet_info.packet_type == _packet_type);
+            } catch (const std::exception& ex) {
+                throw uhd::io_error(
+                    str(boost::format("Radio ctrl (%s) packet parse error - %s") % _name
+                        % ex.what()));
+            }
+
+            // return the readback value
+            if (readback and _outstanding_seqs.empty()) {
+                const uint64_t hi =
+                    (_bige) ? uhd::ntohx(pkt[packet_info.num_header_words32 + 0])
+                            : uhd::wtohx(pkt[packet_info.num_header_words32 + 0]);
+                const uint64_t lo =
+                    (_bige) ? uhd::ntohx(pkt[packet_info.num_header_words32 + 1])
+                            : uhd::wtohx(pkt[packet_info.num_header_words32 + 1]);
+                return ((hi << 32) | lo);
+            }
+        }
+
+        return 0;
+    }
+
+    /*
+     * If ctrl_core waits for a message that didn't arrive it can search for it in the
+     * dump queue. This actually happens during shutdown. handle_async_task can't access
+     * radio_ctrl_cores queue anymore thus it returns the corresponding message. msg_task
+     * class implements a dump_queue to store such messages. With check_dump_queue we can
+     * check if a message we are waiting for got stranded there. If a message got stuck we
+     * get it here and push it onto our own message_queue.
+     */
+    bool check_dump_queue(resp_buff_type& b)
+    {
+        const size_t min_buff_size =
+            8; // Same value as in ant_io_impl->handle_async_task
+        uint32_t recv_sid = (((_sid) << 16) | ((_sid) >> 16));
+        uhd::msg_task::msg_payload_t msg;
+        do {
+            msg = _async_task->get_msg_from_dump_queue(recv_sid);
+        } while (msg.size() < min_buff_size && !msg.empty());
+
+        if (msg.size() >= min_buff_size) {
+            memcpy(b.data, &msg.front(), std::min(msg.size(), sizeof(b.data)));
+            return true;
+        }
+        return false;
+    }
+
+    void push_response(const uint32_t* buff) override
+    {
+        resp_buff_type resp_buff;
+        std::memcpy(resp_buff.data, buff, sizeof(resp_buff));
+        _resp_queue.push_with_haste(resp_buff);
+    }
+
+    void hold_task(uhd::msg_task::sptr task) override
+    {
+        _async_task = task;
+    }
+
+    const vrt::if_packet_info_t::link_type_t _link_type;
+    const vrt::if_packet_info_t::packet_type_t _packet_type;
+    const bool _bige;
+    const uhd::transport::zero_copy_if::sptr _ctrl_xport;
+    const uhd::transport::zero_copy_if::sptr _resp_xport;
+    uhd::msg_task::sptr _async_task;
+    const uint32_t _sid;
+    const std::string _name;
+    std::mutex _mutex;
+    size_t _seq_out;
+    uhd::time_spec_t _time;
+    bool _use_time;
+    double _tick_rate;
+    double _timeout;
+    std::queue<size_t> _outstanding_seqs;
+    bounded_buffer<resp_buff_type> _resp_queue;
+    const size_t _resp_queue_size;
+};
+
+ant_radio_ctrl_core::sptr ant_radio_ctrl_core::make(const bool big_endian,
+    zero_copy_if::sptr ctrl_xport,
+    zero_copy_if::sptr resp_xport,
+    const uint32_t sid,
+    const std::string& name)
+{
+    return sptr(
+        new ant_radio_ctrl_core_impl(big_endian, ctrl_xport, resp_xport, sid, name));
+}
diff --git a/host/lib/usrp/ant/ant_radio_ctrl_core.hpp b/host/lib/usrp/ant/ant_radio_ctrl_core.hpp
new file mode 100644
index 000000000..c076f0812
--- /dev/null
+++ b/host/lib/usrp/ant/ant_radio_ctrl_core.hpp
@@ -0,0 +1,48 @@
+//
+// Copyright 2012-2015 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#pragma once
+
+#include <uhd/transport/zero_copy.hpp>
+#include <uhd/types/time_spec.hpp>
+#include <uhd/types/wb_iface.hpp>
+#include <uhd/utils/msg_task.hpp>
+#include <memory>
+#include <string>
+
+/*!
+ * Provide access to peek, poke for the radio ctrl module
+ */
+class ant_radio_ctrl_core : public uhd::timed_wb_iface
+{
+public:
+    typedef std::shared_ptr<ant_radio_ctrl_core> sptr;
+
+    ~ant_radio_ctrl_core(void) override = 0;
+
+    //! Make a new control object
+    static sptr make(const bool big_endian,
+        uhd::transport::zero_copy_if::sptr ctrl_xport,
+        uhd::transport::zero_copy_if::sptr resp_xport,
+        const uint32_t sid,
+        const std::string& name = "0");
+
+    //! Hold a ref to a task thats feeding push response
+    virtual void hold_task(uhd::msg_task::sptr task) = 0;
+
+    //! Push a response externall (resp_xport is NULL)
+    virtual void push_response(const uint32_t* buff) = 0;
+
+    //! Set the command time that will activate
+    void set_time(const uhd::time_spec_t& time) override = 0;
+
+    //! Get the command time that will activate
+    uhd::time_spec_t get_time(void) override = 0;
+
+    //! Set the tick rate (converting time into ticks)
+    virtual void set_tick_rate(const double rate) = 0;
+};
diff --git a/host/lib/usrp/ant/ant_regs.hpp b/host/lib/usrp/ant/ant_regs.hpp
new file mode 100644
index 000000000..2095d4032
--- /dev/null
+++ b/host/lib/usrp/ant/ant_regs.hpp
@@ -0,0 +1,99 @@
+//
+// Copyright 2012-2013 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#ifndef INCLUDED_ANT_REGS_HPP
+#define INCLUDED_ANT_REGS_HPP
+
+#include <stdint.h>
+
+#define TOREG(x) ((x)*4)
+
+#define localparam static const int
+
+localparam SR_CORE_SPI      = 8;
+localparam SR_CORE_MISC     = 16;
+localparam SR_CORE_COMPAT   = 24;
+localparam SR_CORE_GPSDO_ST = 40;
+localparam SR_CORE_SYNC     = 48;
+localparam RB32_CORE_SPI    = 8;
+localparam RB32_CORE_MISC   = 16;
+localparam RB32_CORE_STATUS = 20;
+localparam RB32_CORE_PLL    = 24;
+
+localparam SR_SPI          = 8;
+localparam SR_ATR          = 12;
+localparam SR_TEST         = 21;
+localparam SR_CODEC_IDLE   = 22;
+localparam SR_READBACK     = 32;
+localparam SR_TX_CTRL      = 64;
+localparam SR_RX_CTRL      = 96;
+localparam SR_RX_DSP       = 144;
+localparam SR_TX_DSP       = 184;
+localparam SR_TIME         = 128;
+localparam SR_RX_FMT       = 136;
+localparam SR_TX_FMT       = 138;
+localparam SR_FP_GPIO      = 200;
+localparam SR_USER_SR_BASE = 253;
+localparam SR_USER_RB_ADDR = 255;
+
+localparam RB32_TEST           = 0;
+localparam RB64_TIME_NOW       = 8;
+localparam RB64_TIME_PPS       = 16;
+localparam RB64_CODEC_READBACK = 24;
+localparam RB32_FP_GPIO        = 32;
+
+// pll constants
+static const int AD9361_SLAVENO      = (1 << 0);
+static const int ADF4001_SLAVENO     = (1 << 1);
+static const double AD9361_SPI_RATE  = 1e6;
+static const double ADF4001_SPI_RATE = 10e3; // slow for large time constant on spi lines
+
+/* ATR Control Bits */
+static const uint32_t TX_ENABLE1   = (1 << 7);
+static const uint32_t SFDX1_RX     = (1 << 6);
+static const uint32_t SFDX1_TX     = (1 << 5);
+static const uint32_t SRX1_RX      = (1 << 4);
+static const uint32_t SRX1_TX      = (1 << 3);
+static const uint32_t LED_RX1      = (1 << 2);
+static const uint32_t LED_TXRX_RX1 = (1 << 1);
+static const uint32_t LED_TXRX_TX1 = (1 << 0);
+
+static const uint32_t TX_ENABLE2   = (1 << 7);
+static const uint32_t SFDX2_RX     = (1 << 6);
+static const uint32_t SFDX2_TX     = (1 << 5);
+static const uint32_t SRX2_RX      = (1 << 4);
+static const uint32_t SRX2_TX      = (1 << 3);
+static const uint32_t LED_RX2      = (1 << 2);
+static const uint32_t LED_TXRX_RX2 = (1 << 1);
+static const uint32_t LED_TXRX_TX2 = (1 << 0);
+
+
+/* ATR State Definitions. */
+static const uint32_t STATE_OFF = 0x00;
+
+///////////////////////// side 1 ///////////////////////////////////
+static const uint32_t STATE_RX1_RX2 = (SFDX1_RX | SFDX1_TX | LED_RX1);
+
+static const uint32_t STATE_RX1_TXRX = (SRX1_RX | SRX1_TX | LED_TXRX_RX1);
+
+static const uint32_t STATE_FDX1_TXRX =
+    (TX_ENABLE1 | SFDX1_RX | SFDX1_TX | LED_TXRX_TX1 | LED_RX1);
+
+static const uint32_t STATE_TX1_TXRX = (TX_ENABLE1 | SFDX1_RX | SFDX1_TX | LED_TXRX_TX1);
+
+///////////////////////// side 2 ///////////////////////////////////
+static const uint32_t STATE_RX2_RX2 = (SFDX2_RX | SRX2_TX | LED_RX2);
+
+static const uint32_t STATE_RX2_TXRX = (SRX2_TX | SRX2_RX | LED_TXRX_RX2);
+
+static const uint32_t STATE_FDX2_TXRX =
+    (TX_ENABLE2 | SFDX2_RX | SFDX2_TX | LED_TXRX_TX2 | LED_RX2);
+
+static const uint32_t STATE_TX2_TXRX = (TX_ENABLE2 | SFDX2_RX | SFDX2_TX | LED_TXRX_TX2);
+
+
+#endif /* INCLUDED_ANT_REGS_HPP */
diff --git a/host/lib/usrp/ant/ant_uart.cpp b/host/lib/usrp/ant/ant_uart.cpp
new file mode 100644
index 000000000..51b4b54fc
--- /dev/null
+++ b/host/lib/usrp/ant/ant_uart.cpp
@@ -0,0 +1,101 @@
+//
+// Copyright 2013 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#include "ant_uart.hpp"
+#include "ant_impl.hpp"
+#include <uhd/exception.hpp>
+#include <uhd/transport/bounded_buffer.hpp>
+#include <uhd/transport/vrt_if_packet.hpp>
+#include <uhd/types/time_spec.hpp>
+#include <uhd/utils/byteswap.hpp>
+#include <uhd/utils/log.hpp>
+
+using namespace uhd;
+using namespace uhd::transport;
+
+struct ant_uart_impl : ant_uart
+{
+    ant_uart_impl(zero_copy_if::sptr xport, const uint32_t sid)
+        : _xport(xport)
+        , _sid(sid)
+        , _count(0)
+        , _baud_div(std::floor(ANT_BUS_CLOCK_RATE / 115200 + 0.5))
+        , _line_queue(4096)
+    {
+        /*NOP*/
+    }
+
+    void send_char(const char ch)
+    {
+        managed_send_buffer::sptr buff = _xport->get_send_buff();
+        UHD_ASSERT_THROW(bool(buff));
+
+        vrt::if_packet_info_t packet_info;
+        packet_info.link_type           = vrt::if_packet_info_t::LINK_TYPE_CHDR;
+        packet_info.packet_type         = vrt::if_packet_info_t::PACKET_TYPE_CONTEXT;
+        packet_info.num_payload_words32 = 2;
+        packet_info.num_payload_bytes =
+            packet_info.num_payload_words32 * sizeof(uint32_t);
+        packet_info.packet_count = _count++;
+        packet_info.sob          = false;
+        packet_info.eob          = false;
+        packet_info.sid          = _sid;
+        packet_info.has_sid      = true;
+        packet_info.has_cid      = false;
+        packet_info.has_tsi      = false;
+        packet_info.has_tsf      = false;
+        packet_info.has_tlr      = false;
+
+        uint32_t* packet_buff = buff->cast<uint32_t*>();
+        vrt::if_hdr_pack_le(packet_buff, packet_info);
+        packet_buff[packet_info.num_header_words32 + 0] = uhd::htowx(uint32_t(_baud_div));
+        packet_buff[packet_info.num_header_words32 + 1] = uhd::htowx(uint32_t(ch));
+        buff->commit(packet_info.num_packet_words32 * sizeof(uint32_t));
+    }
+
+    void write_uart(const std::string& buff) override
+    {
+        for (const char ch : buff) {
+            this->send_char(ch);
+        }
+    }
+
+    std::string read_uart(double timeout) override
+    {
+        std::string line;
+        _line_queue.pop_with_timed_wait(line, timeout);
+        return line;
+    }
+
+    void handle_uart_packet(managed_recv_buffer::sptr buff) override
+    {
+        const uint32_t* packet_buff = buff->cast<const uint32_t*>();
+        vrt::if_packet_info_t packet_info;
+        packet_info.link_type          = vrt::if_packet_info_t::LINK_TYPE_CHDR;
+        packet_info.num_packet_words32 = buff->size() / sizeof(uint32_t);
+        vrt::if_hdr_unpack_le(packet_buff, packet_info);
+        const char ch = char(uhd::wtohx(packet_buff[packet_info.num_header_words32 + 1]));
+        _line += ch;
+        if (ch == '\n') {
+            _line_queue.push_with_pop_on_full(_line);
+            _line.clear();
+        }
+    }
+
+    const zero_copy_if::sptr _xport;
+    const uint32_t _sid;
+    size_t _count;
+    size_t _baud_div;
+    bounded_buffer<std::string> _line_queue;
+    std::string _line;
+};
+
+
+ant_uart::sptr ant_uart::make(zero_copy_if::sptr xport, const uint32_t sid)
+{
+    return ant_uart::sptr(new ant_uart_impl(xport, sid));
+}
diff --git a/host/lib/usrp/ant/ant_uart.hpp b/host/lib/usrp/ant/ant_uart.hpp
new file mode 100644
index 000000000..9b21048a1
--- /dev/null
+++ b/host/lib/usrp/ant/ant_uart.hpp
@@ -0,0 +1,26 @@
+//
+// Copyright 2013 Ettus Research LLC
+// Copyright 2018 Ettus Research, a National Instruments Company
+// Copyright 2019 Ettus Research, a National Instruments Brand
+//
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+
+#ifndef INCLUDED_ANT_UART_HPP
+#define INCLUDED_ANT_UART_HPP
+
+#include <uhd/transport/zero_copy.hpp>
+#include <uhd/types/serial.hpp> //uart iface
+#include <uhd/utils/noncopyable.hpp>
+#include <memory>
+
+class ant_uart : uhd::noncopyable, public uhd::uart_iface
+{
+public:
+    typedef std::shared_ptr<ant_uart> sptr;
+    static sptr make(uhd::transport::zero_copy_if::sptr, const uint32_t sid);
+    virtual void handle_uart_packet(uhd::transport::managed_recv_buffer::sptr buff) = 0;
+};
+
+
+#endif /* INCLUDED_ANT_UART_HPP */
